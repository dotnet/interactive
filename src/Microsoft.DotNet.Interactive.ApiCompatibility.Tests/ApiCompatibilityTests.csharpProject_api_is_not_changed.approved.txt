
  public static class InstrumentationEmitter
    public static System.Void EmitProgramState(Newtonsoft.Json.Linq.JToken programState)
    public static Newtonsoft.Json.Linq.JToken GetProgramState(System.String filePositionStr, System.ValueTuple<System.String,System.Object> variableInfo)
Microsoft.DotNet.Interactive.CSharpProject
  public abstract class AbstractEntryPointFinder : Microsoft.CodeAnalysis.SymbolVisitor
    protected System.Boolean MatchesMainMethodName(System.String name)
    public System.Void VisitMethod(Microsoft.CodeAnalysis.IMethodSymbol symbol)
    public System.Void VisitNamedType(Microsoft.CodeAnalysis.INamedTypeSymbol symbol)
    public System.Void VisitNamespace(Microsoft.CodeAnalysis.INamespaceSymbol symbol)
  public class CSharpProjectKernel
    .ctor()
  public static class DiagnosticExtensions
    public static System.Boolean ContainsError()
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.DiagnosticSeverity ConvertSeverity()
    public static System.Boolean IsError()
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.SerializableDiagnostic ToSerializableDiagnostic(System.String message = null, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId bufferId = null)
  public static class DirectoryAccessExtensions
    public static System.Threading.Tasks.Task<System.IDisposable> TryLockAsync()
  public class EntryPointFinder : AbstractEntryPointFinder
    public static Microsoft.CodeAnalysis.IMethodSymbol FindEntryPoint(Microsoft.CodeAnalysis.INamespaceSymbol symbol)
    .ctor()
    protected System.Boolean MatchesMainMethodName(System.String name)
  public static class ExceptionExtensions
    public static System.Boolean IsConsideredRunFailure()
    public static System.String ToDisplayString()
  public class FindPackageInDefaultLocation, Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor = null)
    public Task<T> Find<T>(Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageDescriptor descriptor)
  public abstract class ICodeCompiler
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompileResult> Compile(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
  public abstract class ICodeRunner
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.RunResult> Run(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
  public abstract class ILanguageService
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompletionResult> GetCompletionList(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.DiagnosticResult> GetDiagnostics(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.SignatureHelpResult> GetSignatureHelp(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
  public class PackageNameIsFullyQualifiedPath, Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder
    .ctor()
    public Task<T> Find<T>(Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageDescriptor descriptor)
  public class PackageNotFoundException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.String message)
  public class PackageRegistry, Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder, System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageBuilder>>, System.Collections.IEnumerable
    public static PackageRegistry CreateForHostedMode()
    .ctor(System.Boolean createRebuildablePackages = False, Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageSource addSource = null, System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder> packageFinders = null, Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageDiscoveryStrategy[] additionalStrategies)
    public System.Void Add(System.String name, System.Action<Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageBuilder> configure)
    public Task<T> Get<T>(System.String packageName, Clockwise.Budget budget = null)
    public System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Packaging.PackageBuilder>> GetEnumerator()
  public class Project
    .ctor(System.Collections.Generic.IReadOnlyCollection<ProjectFile> files)
    public System.Collections.Generic.IReadOnlyCollection<ProjectFile> Files { get;}
  public class ProjectFile
    .ctor(System.String path, System.String content)
    public System.String Content { get;}
    public System.String Path { get;}
  public static class SerializableDiagnosticArrayExtensions
    public static System.Boolean ContainsError()
    public static System.String[] GetCompileErrorMessages()
  public class UriOrFileInfo
    .ctor(System.String value)
    public System.String FileExtension { get;}
    public System.Boolean IsFile { get;}
    public System.String ToString()
Microsoft.DotNet.Interactive.CSharpProject.Commands
  public class CompileProject : Microsoft.DotNet.Interactive.Commands.KernelCommand
    .ctor(System.String code = null)
    public System.String Code { get;}
  public class OpenDocument : Microsoft.DotNet.Interactive.Commands.KernelCommand
    .ctor(System.String path, System.String regionName = null)
    public System.String Path { get;}
    public System.String RegionName { get;}
  public class OpenProject : Microsoft.DotNet.Interactive.Commands.KernelCommand
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Project project)
    public Microsoft.DotNet.Interactive.CSharpProject.Project Project { get;}
Microsoft.DotNet.Interactive.CSharpProject.Events
  public class AssemblyProduced : Microsoft.DotNet.Interactive.Events.KernelEvent
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Commands.CompileProject command, Microsoft.DotNet.Interactive.Base64EncodedAssembly assembly)
    public Microsoft.DotNet.Interactive.Base64EncodedAssembly Assembly { get;}
  public class DocumentOpened : Microsoft.DotNet.Interactive.Events.KernelEvent
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Commands.OpenDocument command, System.String path, System.String regionName, System.String content)
    public System.String Content { get;}
    public System.String Path { get;}
    public System.String RegionName { get;}
Microsoft.DotNet.Interactive.CSharpProject.LanguageServices
  public static class CompletionExtensions
    public static Microsoft.CodeAnalysis.ISymbol GetCompletionSymbolAsync(Microsoft.CodeAnalysis.Completion.CompletionItem completionItem, System.Collections.Generic.Dictionary<System.ValueTuple<System.String,System.Int32>,Microsoft.CodeAnalysis.ISymbol> recommendedSymbols, Microsoft.CodeAnalysis.Document document)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.MarkdownString GetDocumentation(System.Collections.Generic.Dictionary<System.ValueTuple<System.String,System.Int32>,Microsoft.CodeAnalysis.ISymbol> recommendedSymbols, Microsoft.CodeAnalysis.Document document)
    public static System.String GetKind()
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompletionItem ToModel(System.Collections.Generic.Dictionary<System.ValueTuple<System.String,System.Int32>,Microsoft.CodeAnalysis.ISymbol> recommendedSymbols, Microsoft.CodeAnalysis.Document document)
  public class SignatureHelpService
    public static System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.SignatureHelpResult> GetSignatureHelp(Microsoft.CodeAnalysis.Document document, System.Int32 position, Clockwise.Budget budget = null)
    public static System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.SignatureHelpResult> GetSignatureHelp(System.Func<System.Threading.Tasks.Task<Microsoft.CodeAnalysis.SemanticModel>> getSemanticModel, Microsoft.CodeAnalysis.SyntaxNode node, System.Int32 position)
    .ctor()
Microsoft.DotNet.Interactive.CSharpProject.Markdown
  public class AnnotatedCodeBlock : Markdig.Syntax.FencedCodeBlock, Markdig.Syntax.IBlock, Markdig.Syntax.IFencedBlock, Markdig.Syntax.IMarkdownObject
    .ctor(Markdig.Parsers.BlockParser parser = null, System.Int32 order = 0)
    public CodeFenceAnnotations Annotations { get;}
    public System.Collections.Generic.List<System.String> Diagnostics { get;}
    public System.Int32 Order { get;}
    public System.String SourceCode { get; set;}
    public System.Void AddAttribute(System.String key, System.String value)
    public System.Void AddAttributeIfNotExist(System.String key, System.String value)
    protected System.Threading.Tasks.Task AddAttributes(CodeBlockAnnotations annotations)
    public System.Threading.Tasks.Task InitializeAsync()
    public System.Void RenderTo(Markdig.Renderers.HtmlRenderer renderer, System.Boolean inlineControls, System.Boolean enablePreviewFeatures)
  public class AnnotatedCodeBlockParser : Markdig.Parsers.FencedBlockParserBase<AnnotatedCodeBlock>, Markdig.Parsers.IAttributesParseable, Markdig.Parsers.IBlockParser<Markdig.Parsers.BlockProcessor>, Markdig.Parsers.IMarkdownParser<Markdig.Parsers.BlockProcessor>
    .ctor(CodeFenceAnnotationsParser codeFenceAnnotationsParser)
    protected AnnotatedCodeBlock CreateFencedBlock(Markdig.Parsers.BlockProcessor processor)
    protected System.Boolean ParseCodeOptions(Markdig.Parsers.BlockProcessor state, ref Markdig.Helpers.StringSlice& line, Markdig.Syntax.IFencedBlock fenced, System.Char openingCharacter)
    public Markdig.Parsers.BlockState TryContinue(Markdig.Parsers.BlockProcessor processor, Markdig.Syntax.Block block)
  public class AnnotatedCodeBlockRenderer : Markdig.Renderers.Html.CodeBlockRenderer, Markdig.Renderers.IMarkdownObjectRenderer
    .ctor()
    public System.Boolean EnablePreviewFeatures { get; set;}
    public System.Boolean InlineControls { get; set;}
    protected System.Void Write(Markdig.Renderers.HtmlRenderer renderer, Markdig.Syntax.CodeBlock codeBlock)
  public class CodeBlockAnnotationExtension, Markdig.IMarkdownExtension
    .ctor(CodeFenceAnnotationsParser annotationsParser = null)
    public System.Boolean EnablePreviewFeatures { get; set;}
    public System.Boolean InlineControls { get; set;}
    public System.Void Setup(Markdig.MarkdownPipelineBuilder pipeline)
    public System.Void Setup(Markdig.MarkdownPipeline pipeline, Markdig.Renderers.IMarkdownRenderer renderer)
  public class CodeBlockAnnotations : CodeFenceAnnotations
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Tools.RelativeFilePath destinationFile = null, System.String package = null, System.String region = null, System.String session = null, System.Boolean editable = False, System.Boolean hidden = False, System.String runArgs = null, System.CommandLine.Parsing.ParseResult parseResult = null, System.String packageVersion = null)
    public Microsoft.DotNet.Interactive.CSharpProject.Tools.RelativeFilePath DestinationFile { get;}
    public System.Boolean Editable { get;}
    public System.Boolean Hidden { get;}
    public System.String Package { get;}
    public System.String PackageVersion { get;}
    public System.String Region { get;}
    public System.Threading.Tasks.Task AddAttributes(AnnotatedCodeBlock block)
    public System.Threading.Tasks.Task<CodeBlockContentFetchResult> TryGetExternalContent()
  public abstract class CodeBlockContentFetchResult
    public static CodeBlockContentFetchResult None { get;}
    public static CodeBlockContentFetchResult Failed(System.Collections.Generic.IList<System.String> errorMessages)
    public static CodeBlockContentFetchResult Succeeded(System.String content)
  public abstract class CodeFenceAnnotations
    public System.String Language { get;}
    public System.String NormalizedLanguage { get;}
    public System.CommandLine.Parsing.ParseResult ParseResult { get;}
    public System.String RunArgs { get;}
    public System.String Session { get;}
    protected System.Void set_Session(System.String value)
  public class CodeFenceAnnotationsParser
    .ctor(IDefaultCodeBlockAnnotations defaultAnnotations = null, System.Action<System.CommandLine.Command> configureCsharpCommand = null, System.Action<System.CommandLine.Command> configureFsharpCommand = null, System.Action<System.CommandLine.Command> configureConsoleCommand = null)
    public System.Type CodeBlockAnnotationsType { get;}
    public CodeFenceOptionsParseResult TryParseCodeFenceOptions(System.String line, Markdig.MarkdownParserContext parserContext = null)
  public abstract class CodeFenceOptionsParseResult
    public static CodeFenceOptionsParseResult None { get;}
    public static CodeFenceOptionsParseResult Failed(System.Collections.Generic.IList<System.String> errorMessages)
    public static CodeFenceOptionsParseResult Failed(System.String errorMessage)
    public static CodeFenceOptionsParseResult Succeeded(CodeFenceAnnotations annotations)
  public class DefaultCodeBlockAnnotations, IDefaultCodeBlockAnnotations
    .ctor()
    public System.String Package { get; set;}
    public System.String PackageVersion { get; set;}
  public class ExternalContentNotEnabledResult : CodeBlockContentFetchResult
    .ctor()
  public class FailedCodeBlockContentFetchResult : CodeBlockContentFetchResult
    .ctor(System.Collections.Generic.IList<System.String> errorMessages)
    public System.Collections.Generic.IList<System.String> ErrorMessages { get;}
  public class FailedCodeFenceOptionParseResult : CodeFenceOptionsParseResult
    .ctor(System.Collections.Generic.IList<System.String> errorMessages)
    public System.Collections.Generic.IList<System.String> ErrorMessages { get;}
  public abstract class IDefaultCodeBlockAnnotations
    public System.String Package { get;}
    public System.String PackageVersion { get;}
  public static class MarkdownNormalizePipelineBuilderExtensions
    public static Markdig.MarkdownPipelineBuilder UseNormalizeCodeBlockAnnotations(System.Collections.Generic.Dictionary<System.String,System.String> outputsBySessionName)
  public static class MarkdownParserContextExtensions
    public static Markdig.MarkdownParserContext AddDefaultCodeBlockAnnotations(System.Action<DefaultCodeBlockAnnotations> configure)
    public static System.Boolean TryGetDefaultCodeBlockAnnotations(ref DefaultCodeBlockAnnotations& defaults)
  public static class MarkdownPipelineBuilderExtensions
    public static Markdig.MarkdownPipelineBuilder UseCodeBlockAnnotations(CodeFenceAnnotationsParser annotationsParser = null, System.Boolean inlineControls = True)
  public class NoCodeFenceOptions : CodeFenceOptionsParseResult
  public class NormalizeBlockAnnotationExtension, Markdig.IMarkdownExtension
    .ctor(System.Collections.Generic.Dictionary<System.String,System.String> outputsBySessionName)
    public System.Void Setup(Markdig.MarkdownPipelineBuilder pipeline)
    public System.Void Setup(Markdig.MarkdownPipeline pipeline, Markdig.Renderers.IMarkdownRenderer renderer)
   class AnnotatedCodeBlockRenderer : Markdig.Renderers.Normalize.CodeBlockRenderer, Markdig.Renderers.IMarkdownObjectRenderer
    .ctor(System.Collections.Generic.Dictionary<System.String,System.String> outputsBySessionName)
    protected System.Void Write(Markdig.Renderers.Normalize.NormalizeRenderer renderer, Markdig.Syntax.CodeBlock codeBlock)
  public class OutputBlockAnnotations : CodeFenceAnnotations
    .ctor(System.CommandLine.Parsing.ParseResult parseResult = null, System.String session = null)
  public class SkipEmptyLinkReferencesExtension, Markdig.IMarkdownExtension
    .ctor()
    public System.Void Setup(Markdig.MarkdownPipelineBuilder pipeline)
    public System.Void Setup(Markdig.MarkdownPipeline pipeline, Markdig.Renderers.IMarkdownRenderer renderer)
   class SkipEmptyLinkReferencesRender : Markdig.Renderers.Normalize.LinkReferenceDefinitionRenderer, Markdig.Renderers.IMarkdownObjectRenderer
    .ctor()
    protected System.Void Write(Markdig.Renderers.Normalize.NormalizeRenderer renderer, Markdig.Syntax.LinkReferenceDefinition linkDef)
  public class SuccessfulCodeBlockContentFetchResult : CodeBlockContentFetchResult
    .ctor(System.String content)
    public System.String Content { get;}
  public class SuccessfulCodeFenceOptionParseResult : CodeFenceOptionsParseResult
    public CodeFenceAnnotations Annotations { get;}
  public class SvgResources
    .ctor()
Microsoft.DotNet.Interactive.CSharpProject.MLS.Project
  public class BufferFromRegionExtractor
    .ctor()
    public Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace Extract(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.Protocol.File> sourceFiles, System.String workspaceType = null, System.String[] usings = null)
  public static class BufferGenerator
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer CreateBuffer(System.String content, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId id)
    public static System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer> CreateBuffers(Microsoft.DotNet.Interactive.CSharpProject.Protocol.File file)
  public class BufferInliningTransformer, IWorkspaceTransformer
    public static IWorkspaceTransformer Instance { get;}
    public static System.Int32 PaddingSize { get;}
    .ctor()
    protected System.Threading.Tasks.Task InjectBuffer(Viewport viewPort, Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer sourceBuffer, System.Collections.Generic.ICollection<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer> buffers, System.Collections.Generic.IDictionary<System.String,SourceFile> files, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferInjectionPoints bufferIdInjectionPoints)
    protected System.Threading.Tasks.Task InjectBufferAtSpan(Viewport viewPort, Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer sourceBuffer, System.Collections.Generic.ICollection<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer> buffers, System.Collections.Generic.IDictionary<System.String,SourceFile> files, Microsoft.CodeAnalysis.Text.TextSpan span)
    protected System.Threading.Tasks.Task<System.ValueTuple<Microsoft.DotNet.Interactive.CSharpProject.Protocol.File[],Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer[]>> InlineBuffersAsync(Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace source)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> TransformAsync(Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace source)
  public class CodeMergeTransformer, IWorkspaceTransformer
    public static IWorkspaceTransformer Instance { get;}
    .ctor()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> TransformAsync(Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace source)
  public static class FileExtensions
    public static System.Collections.Generic.IEnumerable<Viewport> ExtractViewports()
    public static System.Collections.Generic.IEnumerable<Viewport> ExtractViewports()
    public static System.Collections.Generic.IEnumerable<Viewport> ExtractViewPorts()
    public static System.Collections.Generic.IEnumerable<Viewport> ExtractViewPorts()
    public static SourceFile ToSourceFile()
  public static class FileGenerator
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.File Create(System.String name, System.String content)
  public abstract class IWorkspaceTransformer
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> TransformAsync(Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace source)
  public static class MarkupTestFile
    public static System.Void GetNamedSpans(System.String input, ref System.String& output, ref System.Collections.Generic.IDictionary<System.String,System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Text.TextSpan>> spans)
    public static System.Void GetPosition(System.String input, ref System.String& output, ref System.Nullable<System.Int32> cursorPosition)
    public static System.Void GetPositionAndNamedSpans(System.String input, ref System.String& output, ref System.Nullable<System.Int32> cursorPositionOpt, ref System.Collections.Generic.IDictionary<System.String,System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Text.TextSpan>> spans)
    public static System.Void GetPositionAndSpan(System.String input, ref System.String& output, ref System.Nullable<System.Int32> cursorPosition, ref System.Nullable<Microsoft.CodeAnalysis.Text.TextSpan> textSpan)
    public static System.Void GetPositionAndSpan(System.String input, ref System.String& output, ref System.Nullable<System.Int32> cursorPosition, ref Microsoft.CodeAnalysis.Text.TextSpan& textSpan)
    public static System.Void GetSpan(System.String input, ref System.String& output, ref Microsoft.CodeAnalysis.Text.TextSpan& textSpan)
    public static System.Void GetSpans(System.String input, ref System.String& output, ref System.Collections.Immutable.ImmutableArray<Microsoft.CodeAnalysis.Text.TextSpan> spans)
  public class SourceFile
    public static SourceFile Create(System.String text, System.String name)
    public System.String Name { get;}
    public Microsoft.CodeAnalysis.Text.SourceText Text { get;}
  public static class SourceTextExtensions
    public static System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Buffer> ExtractBuffers(System.String fileName)
    public static System.Collections.Generic.IEnumerable<System.ValueTuple<Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.TextSpan>> ExtractRegions(System.String fileName)
    public static System.String FormatSourceCode(System.String fileName)
  public static class TextGenerator
    public static System.Char GetLowerCaseLetter()
  public class Viewport
    .ctor(SourceFile destination, Microsoft.CodeAnalysis.Text.TextSpan region, Microsoft.CodeAnalysis.Text.TextSpan outerRegion, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId bufferId)
    public Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId BufferId { get;}
    public SourceFile Destination { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan OuterRegion { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan Region { get;}
  public static class WorkspaceExtensions
    public static System.Collections.Generic.IEnumerable<Viewport> ExtractViewPorts()
    public static System.Collections.Generic.IReadOnlyCollection<SourceFile> GetSourceFiles()
    public static System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> InlineBuffersAsync()
    public static System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> InlineBuffersAsync()
    public static System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace> MergeAsync()
Microsoft.DotNet.Interactive.CSharpProject.Models
  public class DocumentationComment
    public static DocumentationComment From(System.String xmlDocumentation, System.String lineEnding)
    .ctor(System.String summaryText = , DocumentationItem[] typeParamElements = null, DocumentationItem[] paramElements = null, System.String returnsText = , System.String remarksText = , System.String exampleText = , System.String valueText = , DocumentationItem[] exception = null)
    public System.String ExampleText { get;}
    public DocumentationItem[] Exception { get;}
    public DocumentationItem[] ParamElements { get;}
    public System.String RemarksText { get;}
    public System.String ReturnsText { get;}
    public System.String SummaryText { get;}
    public DocumentationItem[] TypeParamElements { get;}
    public System.String ValueText { get;}
    public System.String GetParameterText(System.String name)
    public System.String GetTypeParameterText(System.String name)
  public static class DocumentationConverter
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.MarkdownString GetDocumentation(Microsoft.CodeAnalysis.ISymbol symbol, System.String lineEnding)
    public static DocumentationComment GetDocumentationComment(Microsoft.CodeAnalysis.ISymbol symbol, System.String lineEnding)
  public class DocumentationItem
    .ctor(System.String name, System.String documentation)
    public System.String Documentation { get;}
    public System.String Name { get;}
  public static class WorkspaceRequestFactory
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest CreateRequestFromDirectory(System.IO.DirectoryInfo directory, System.String workspaceType)
Microsoft.DotNet.Interactive.CSharpProject.Models.Execution
  public static class HttpRequestExtensions
    public static System.Net.Http.HttpRequestMessage ToHttpRequestMessage()
  public static class WorkspaceExtensions
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace AddBuffer(System.String id, System.String text)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace AddFile(System.String name, System.String text)
    public static System.Int32 GetAbsolutePositionForGetBufferWithSpecifiedIdOrSingleBufferIfThereIsOnlyOne(Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId bufferId = null)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.File GetFileFromBufferId(Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId bufferId)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace RemoveBuffer(System.String id)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace ReplaceBuffer(System.String id, System.String text)
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace ReplaceFile(System.String name, System.String text)
  public class WorkspaceFactory
    public static Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace CreateWorkspaceFromDirectory(System.IO.DirectoryInfo directory, System.String workspaceType, System.Boolean includeInstrumentation = False)
    .ctor()
Microsoft.DotNet.Interactive.CSharpProject.Models.Instrumentation
  public class Location
    .ctor()
    public System.Int64 EndColumn { get; set;}
    public System.Int64 EndLine { get; set;}
    public System.Int64 StartColumn { get; set;}
    public System.Int64 StartLine { get; set;}
  public class ProgramDescriptor, Microsoft.DotNet.Interactive.CSharpProject.Protocol.IRunResultFeature
    .ctor()
    public System.String Name { get;}
    public VariableLocation[] VariableLocations { get; set;}
    public System.Void Apply(Microsoft.DotNet.Interactive.CSharpProject.Protocol.FeatureContainer result)
  public class ProgramStateAtPositionArray, Microsoft.DotNet.Interactive.CSharpProject.Protocol.IRunResultFeature
    .ctor(System.Collections.Generic.IReadOnlyCollection<System.String> programStates)
    public System.String Name { get;}
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.Servers.Roslyn.Instrumentation.ProgramStateAtPosition> ProgramStates { get; set;}
    public System.Void Apply(Microsoft.DotNet.Interactive.CSharpProject.Protocol.FeatureContainer result)
  public class VariableLocation
    .ctor()
    public Location[] Locations { get; set;}
    public System.String Name { get; set;}
    public Microsoft.DotNet.Interactive.CSharpProject.Servers.Roslyn.Instrumentation.LineRange RangeOfLines { get; set;}
Microsoft.DotNet.Interactive.CSharpProject.Models.SignatureHelp
  public class InvocationContext
    .ctor(Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Int32 position, Microsoft.CodeAnalysis.SyntaxNode receiver, Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax argList)
    .ctor(Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Int32 position, Microsoft.CodeAnalysis.SyntaxNode receiver, Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax argList)
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.TypeInfo> ArgumentTypes { get;}
    public System.Int32 Position { get;}
    public Microsoft.CodeAnalysis.SyntaxNode Receiver { get;}
    public Microsoft.CodeAnalysis.SemanticModel SemanticModel { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken> Separators { get;}
Microsoft.DotNet.Interactive.CSharpProject.Packaging
  public static class AnalyzerResultExtensions
    public static System.String[] GetCompileInputs()
    public static Microsoft.CodeAnalysis.CSharp.CSharpParseOptions GetCSharpParseOptions()
  public class BlazorPackage : PackageBase, ICanSupportWasm, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    .ctor(System.String name, IPackageInitializer initializer = null, System.IO.DirectoryInfo directory = null)
    public System.IO.FileInfo BlazorEntryPointAssemblyPath { get;}
    public System.String CodeRunnerPath { get;}
    public System.String CodeRunnerPathBase { get;}
  public class BlazorPackageInitializer : PackageInitializer, IPackageInitializer
    .ctor(System.String name, System.Collections.Generic.List<System.ValueTuple<System.String,System.String,System.String>> addPackages)
    public System.Threading.Tasks.Task Initialize(System.IO.DirectoryInfo directory, Clockwise.Budget budget = null)
  public class ContentAsset : PackageAsset
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor)
  public class FileLock
    public static System.Boolean IsLockFile(System.IO.FileInfo fileInfo)
    public static System.Threading.Tasks.Task<System.IDisposable> TryCreateAsync(System.IO.FileInfo lockFile)
    public static System.Threading.Tasks.Task<System.IDisposable> TryCreateAsync(Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor)
    public static System.Threading.Tasks.Task<System.IDisposable> TryCreateAsync(System.IO.DirectoryInfo directory)
    .ctor()
  public class FileTextLoader : Microsoft.CodeAnalysis.TextLoader
    .ctor(System.String absolutePath)
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.TextAndVersion> LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace workspace, Microsoft.CodeAnalysis.DocumentId documentId, System.Threading.CancellationToken cancellationToken)
  public abstract class ICanSupportWasm, IPackage
    public System.Boolean CanSupportWasm { get;}
  public abstract class ICreateWorkspace, IPackage
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceAsync(Clockwise.Budget budget)
  public abstract class ICreateWorkspaceForLanguageServices, ICreateWorkspace, IPackage
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForLanguageServicesAsync(Clockwise.Budget budget)
  public abstract class ICreateWorkspaceForRun, ICreateWorkspace, IPackage
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForRunAsync(Clockwise.Budget budget)
  public abstract class IHaveADirectory, IPackage
    public System.IO.DirectoryInfo Directory { get;}
  public abstract class IHaveADirectoryAccessor, IPackage
    public Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor Directory { get;}
  public abstract class IPackage
    public System.String Name { get;}
  public abstract class IPackageAssetLoader
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<PackageAsset>> LoadAsync(Package2 package)
  public abstract class IPackageDiscoveryStrategy
    public System.Threading.Tasks.Task<PackageBuilder> Locate(PackageDescriptor packageInfo, Clockwise.Budget budget = null)
  public abstract class IPackageFinder
    public Task<T> Find<T>(PackageDescriptor descriptor)
  public abstract class IPackageInitializer
    public System.Threading.Tasks.Task Initialize(System.IO.DirectoryInfo directory, Clockwise.Budget budget = null)
  public abstract class IPipelineStep
    public System.Void Invalidate()
  public class NonrebuildablePackage : Package, ICanSupportWasm, ICreateWorkspace, ICreateWorkspaceForLanguageServices, ICreateWorkspaceForRun, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    .ctor(System.String name = null, IPackageInitializer initializer = null, System.IO.DirectoryInfo directory = null, System.Reactive.Concurrency.IScheduler buildThrottleScheduler = null)
  public abstract class Package : PackageBase, ICanSupportWasm, ICreateWorkspace, ICreateWorkspaceForLanguageServices, ICreateWorkspaceForRun, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    public static System.IO.DirectoryInfo DefaultPackagesDirectory { get;}
    public System.IO.FileInfo EntryPointAssemblyPath { get;}
    public System.Boolean IsUnitTestProject { get;}
    public System.Boolean IsWebProject { get;}
    public System.Nullable<System.DateTimeOffset> PublicationTime { get;}
    public System.Boolean RequiresPublish { get;}
    public System.String TargetFramework { get;}
    protected Microsoft.CodeAnalysis.SyntaxTree CreateInstrumentationEmitterSyntaxTree()
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceAsync(Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForLanguageServicesAsync(Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForRunAsync(Clockwise.Budget budget)
    protected System.Threading.Tasks.Task<Buildalyzer.IAnalyzerResult> DesignTimeBuild()
    protected System.Threading.Tasks.Task EnsureBuilt(System.String caller = null)
    protected System.Threading.Tasks.Task EnsureDesignTimeBuilt(System.String caller = null)
    public System.Threading.Tasks.Task EnsurePublished()
    public System.Threading.Tasks.Task EnsureReady(Clockwise.Budget budget)
    public System.Threading.Tasks.Task FullBuild()
    protected Buildalyzer.IAnalyzerResult get_DesignTimeBuildResult()
    protected Microsoft.CodeAnalysis.Workspace get_RoslynWorkspace()
    public Microsoft.CodeAnalysis.SyntaxTree GetInstrumentationEmitterSyntaxTree()
    protected System.Threading.Tasks.Task Publish()
    protected System.Void set_DesignTimeBuildResult(Buildalyzer.IAnalyzerResult value)
    protected System.Void set_RoslynWorkspace(Microsoft.CodeAnalysis.Workspace value)
    protected System.Boolean ShouldDoDesignTimeBuild()
    protected System.Boolean ShouldDoFullBuild()
    public System.String ToString()
  public class Package2, ICanSupportWasm, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    .ctor(System.String name, Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor)
    .ctor(PackageDescriptor descriptor, Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor)
    public System.Collections.Generic.IEnumerable<PackageAsset> Assets { get;}
    public System.Boolean CanSupportWasm { get;}
    public System.IO.DirectoryInfo Directory { get;}
    public Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor DirectoryAccessor { get;}
    public System.String Name { get;}
    public System.String Version { get;}
    public System.Void Add(PackageAsset asset)
    public System.Threading.Tasks.Task EnsureLoadedAsync(System.Collections.Generic.IEnumerable<IPackageAssetLoader> assetLoaders = null)
  public abstract class PackageAsset
    public Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor DirectoryAccessor { get;}
  public abstract class PackageBase, ICanSupportWasm, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    public System.Boolean CanSupportWasm { get;}
    public System.IO.DirectoryInfo Directory { get; set;}
    public IPackageInitializer Initializer { get;}
    public System.String Name { get;}
    protected System.Threading.Tasks.Task DotnetBuild()
    protected System.Threading.Tasks.Task EnsureBuilt(System.String caller = null)
    protected System.Threading.Tasks.Task<System.Boolean> EnsureCreated()
    public System.Threading.Tasks.Task EnsureReady(Clockwise.Budget budget)
    public System.Threading.Tasks.Task FullBuild()
    protected System.IO.FileInfo get_LastBuildErrorLogFile()
    protected System.Void set_Initializer(IPackageInitializer value)
  public class PackageBuilder
    .ctor(System.String packageName, IPackageInitializer packageInitializer = null)
    public System.Boolean BlazorSupported { get;}
    public System.Boolean CreateRebuildablePackage { get; set;}
    public System.IO.DirectoryInfo Directory { get; set;}
    public IPackageInitializer PackageInitializer { get;}
    public System.String PackageName { get;}
    public System.Void AddPackageReference(System.String packageId, System.String version = null, System.String restoreSources = null)
    public System.Void CreateUsingDotnet(System.String template, System.String projectName = null, System.String language = null)
    public System.Void DeleteFile(System.String relativePath)
    public PackageBase GetPackage(Clockwise.Budget budget = null)
    public System.Void SetLanguageVersion(System.String version)
    public System.Void TrySetLanguageVersion(System.String version)
    public System.Void WriteFile(System.String relativePath, System.String content)
  public class PackageDescriptor
    .ctor(System.String name, System.String version = null)
    public System.String Name { get;}
    public System.String Version { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Int32 GetHashCode()
    public System.String ToString()
  public static class PackageFinder
    public static IPackageFinder Create(IPackage package)
    public static Task<T> Find<T>(System.String packageName, Clockwise.Budget budget = null)
  public class PackageInitializer, IPackageInitializer
    .ctor(System.String template, System.String projectName, System.String language = null, System.Func<System.IO.DirectoryInfo,Clockwise.Budget,System.Threading.Tasks.Task> afterCreate = null)
    public System.String Language { get;}
    public System.String ProjectName { get;}
    public System.String Template { get;}
    public System.Threading.Tasks.Task Initialize(System.IO.DirectoryInfo directory, Clockwise.Budget budget = null)
  public class PackageSource
    .ctor(System.String value)
    public System.String ToString()
  public class PipelineStep<T>, IPipelineStep
    .ctor(Func<Task<T>> createValue)
    public Task<T> GetLatestAsync()
    public System.Void Invalidate()
    public PipelineStep<U> Then<U>(Func<T,Task<U>> nextStep)
  public class ProjectAsset : PackageAsset, ICreateWorkspace, ICreateWorkspaceForLanguageServices, ICreateWorkspaceForRun, IHaveADirectory, IPackage
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor, System.String csprojFileName = null)
    public System.IO.DirectoryInfo Directory { get;}
    public System.String Name { get;}
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceAsync(Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForLanguageServicesAsync(Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace> CreateRoslynWorkspaceForRunAsync(Clockwise.Budget budget)
    protected System.Threading.Tasks.Task DotnetBuild()
  public class ProjectAssetLoader, IPackageAssetLoader
    .ctor()
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<PackageAsset>> LoadAsync(Package2 package)
  public class ProjectFilePackageDiscoveryStrategy, IPackageDiscoveryStrategy
    .ctor(System.Boolean createRebuildablePackage)
    public System.Threading.Tasks.Task<PackageBuilder> Locate(PackageDescriptor packageDescriptor, Clockwise.Budget budget = null)
  public class RebuildablePackage : Package, ICanSupportWasm, ICreateWorkspace, ICreateWorkspaceForLanguageServices, ICreateWorkspaceForRun, IHaveADirectory, IHaveADirectoryAccessor, IPackage
    .ctor(System.String name = null, IPackageInitializer initializer = null, System.IO.DirectoryInfo directory = null, System.Reactive.Concurrency.IScheduler buildThrottleScheduler = null)
    protected System.Threading.Tasks.Task EnsureBuilt(System.String caller = null)
    public System.Threading.Tasks.Task EnsureReady(Clockwise.Budget budget)
  public class WebAssemblyAsset : PackageAsset
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Tools.IDirectoryAccessor directoryAccessor)
Microsoft.DotNet.Interactive.CSharpProject.Protocol
  public class Buffer
    .ctor(BufferId id, System.String content, System.Int32 position = 0, System.Int32 offSetFromParentBuffer = 0, System.Int32 order = 0)
    public System.Int32 AbsolutePosition { get;}
    public System.String Content { get;}
    public BufferId Id { get;}
    public System.Int32 Order { get;}
    public System.Int32 Position { get;}
    public System.String ToString()
  public static class BufferExtensions
    public static Buffer GetBufferWithSpecifiedIdOrSingleBufferIfThereIsOnlyOne(BufferId bufferId = null)
  public class BufferId
    public static BufferId Empty { get;}
    public static System.Boolean op_Equality(BufferId left, BufferId right)
    public static BufferId op_Implicit(System.String value)
    public static System.Boolean op_Inequality(BufferId left, BufferId right)
    public static BufferId Parse(System.String value)
    .ctor(System.String fileName, System.String regionName = null)
    public System.String FileName { get;}
    public System.String RegionName { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Int32 GetHashCode()
    public BufferInjectionPoints GetInjectionPoint()
    public BufferId GetNormalized()
    public System.String ToString()
  public enum BufferInjectionPoints : System.Enum, System.IComparable, System.IConvertible, System.IFormattable
    Replace=0
    Before=1
    After=2
  public class ClientConfiguration
    .ctor(System.String versionId, RequestDescriptors links, System.Int32 defaultTimeoutMs, System.String applicationInsightsKey, System.Boolean enableBranding)
    public System.String ApplicationInsightsKey { get;}
    public System.Int32 DefaultTimeoutMs { get;}
    public System.Boolean EnableBranding { get;}
    public RequestDescriptors Links { get;}
    public System.String VersionId { get;}
  public class CompileResult : FeatureContainer, System.IDisposable
    .ctor(System.Boolean succeeded, System.String base64assembly, System.Collections.Generic.IEnumerable<SerializableDiagnostic> diagnostics = null, System.String requestId = null)
    public System.String Base64Assembly { get;}
    public System.String RequestId { get;}
    public System.Boolean Succeeded { get;}
  public class CompletionItem
    .ctor(System.String displayText, System.String kind, System.String filterText = null, System.String sortText = null, System.String insertText = null, MarkdownString documentation = null, System.Uri acceptanceUri = null)
    public System.Uri AcceptanceUri { get;}
    public System.String DisplayText { get;}
    public MarkdownString Documentation { get; set;}
    public System.String FilterText { get;}
    public System.String InsertText { get;}
    public System.String Kind { get;}
    public System.String SortText { get;}
    public System.String ToString()
  public class CompletionResult
    .ctor(CompletionItem[] items = null, System.Collections.Generic.IEnumerable<SerializableDiagnostic> diagnostics = null, System.String requestId = null)
    public System.Collections.Generic.IEnumerable<SerializableDiagnostic> Diagnostics { get;}
    public CompletionItem[] Items { get;}
    public System.String RequestId { get;}
  public static class CompletionUtilities
    public static System.Collections.Generic.IEnumerable<CompletionItem> Deduplicate()
  public class DiagnosticResult
    .ctor(System.Collections.Generic.IReadOnlyCollection<SerializableDiagnostic> diagnostics = null, System.String requestId = null)
    public System.Collections.Generic.IReadOnlyCollection<SerializableDiagnostic> Diagnostics { get; set;}
    public System.String RequestId { get;}
  public class Diagnostics : System.Collections.ObjectModel.ReadOnlyCollection<SerializableDiagnostic>, IRunResultFeature, System.Collections.Generic.ICollection<SerializableDiagnostic>, System.Collections.Generic.IEnumerable<SerializableDiagnostic>, System.Collections.Generic.IList<SerializableDiagnostic>, System.Collections.Generic.IReadOnlyCollection<SerializableDiagnostic>, System.Collections.Generic.IReadOnlyList<SerializableDiagnostic>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
    .ctor(System.Collections.Generic.IList<SerializableDiagnostic> list)
    public System.String Name { get;}
    public System.Void Apply(FeatureContainer result)
  public enum DiagnosticSeverity : System.Enum, System.IComparable, System.IConvertible, System.IFormattable
    Hidden=0
    Info=1
    Warning=2
    Error=3
  public abstract class FeatureContainer, System.IDisposable
    public System.Collections.Generic.List<System.ValueTuple<System.String,System.Object>> FeatureProperties { get;}
    public System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object> Features { get;}
    public System.Void AddFeature(IRunResultFeature feature)
    public System.Void AddProperty(System.String name, System.Object value)
    public System.Void Dispose()
  public class File
    .ctor(System.String name, System.String text, System.Int32 order = 0)
    public System.String Name { get;}
    public System.Int32 Order { get;}
    public System.String Text { get;}
    public System.String ToString()
  public class HttpRequest
    .ctor(System.String uri, System.String verb, System.String body = null)
    public System.String Body { get;}
    public System.Uri Uri { get;}
    public System.String Verb { get;}
  public abstract class IRunResultFeature
    public System.String Name { get;}
    public System.Void Apply(FeatureContainer result)
  public class MarkdownString
    public static MarkdownString op_Implicit(System.String value)
    .ctor(System.String value, System.Boolean isTrusted = False)
    public System.Boolean IsTrusted { get;}
    public System.String Value { get;}
  public class Package
    .ctor(System.Boolean isWasmSupported)
    public System.Boolean IsWasmSupported { get;}
  public class ProjectDiagnostics : System.Collections.ObjectModel.ReadOnlyCollection<SerializableDiagnostic>, IRunResultFeature, System.Collections.Generic.ICollection<SerializableDiagnostic>, System.Collections.Generic.IEnumerable<SerializableDiagnostic>, System.Collections.Generic.IList<SerializableDiagnostic>, System.Collections.Generic.IReadOnlyCollection<SerializableDiagnostic>, System.Collections.Generic.IReadOnlyList<SerializableDiagnostic>, System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList
    .ctor(System.Collections.Generic.IEnumerable<SerializableDiagnostic> diagnostics)
    public System.String Name { get;}
    public System.Void Apply(FeatureContainer result)
  public class RequestDescriptor
    .ctor(System.String href, System.String method = null, System.Boolean templated = False, System.Collections.Generic.IReadOnlyCollection<RequestDescriptorProperty> properties = null, System.String requestBody = null, System.Int32 timeoutMs = 15000)
    public System.String Body { get;}
    public System.String Href { get;}
    public System.String Method { get;}
    public System.Collections.Generic.IEnumerable<RequestDescriptorProperty> Properties { get;}
    public System.Boolean Templated { get;}
    public System.Int32 TimeoutMs { get;}
  public class RequestDescriptorProperty
    .ctor(System.String name, System.Object value = null)
    public System.String Name { get;}
    public System.Object Value { get;}
  public class RequestDescriptors
    .ctor(RequestDescriptor self)
    public RequestDescriptor AcceptCompletion { get; set;}
    public RequestDescriptor Compile { get; set;}
    public RequestDescriptor Completion { get; set;}
    public RequestDescriptor Configuration { get; set;}
    public RequestDescriptor Diagnostics { get; set;}
    public RequestDescriptor GetPackage { get; set;}
    public RequestDescriptor LoadFromGist { get; set;}
    public RequestDescriptor ProjectFromGist { get; set;}
    public RequestDescriptor RegionsFromFiles { get; set;}
    public RequestDescriptor Run { get; set;}
    public RequestDescriptor Self { get;}
    public RequestDescriptor SignatureHelp { get; set;}
    public RequestDescriptor Snippet { get; set;}
    public RequestDescriptor Version { get; set;}
  public class RunResult : FeatureContainer, System.IDisposable
    .ctor(System.Boolean succeeded, System.Collections.Generic.IReadOnlyCollection<System.String> output = null, System.String exception = null, System.Collections.Generic.IEnumerable<SerializableDiagnostic> diagnostics = null, System.String requestId = null)
    public System.String Exception { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.String> Output { get;}
    public System.String RequestId { get;}
    public System.Boolean Succeeded { get;}
    public System.String ToString()
  public static class RunResultExtensions
    public static T GetFeature<T>()
  public class SerializableDiagnostic
    .ctor(System.Int32 start, System.Int32 end, System.String message, DiagnosticSeverity severity, System.String id, BufferId bufferId = null, System.String location = null)
    public BufferId BufferId { get;}
    public System.Int32 End { get;}
    public System.String Id { get;}
    public System.String Location { get;}
    public System.String Message { get;}
    public DiagnosticSeverity Severity { get;}
    public System.Int32 Start { get;}
  public class SignatureHelpItem
    .ctor()
    public MarkdownString Documentation { get; set;}
    public System.String Label { get; set;}
    public System.String Name { get; set;}
    public System.Collections.Generic.IEnumerable<SignatureHelpParameter> Parameters { get; set;}
  public class SignatureHelpParameter
    .ctor()
    public MarkdownString Documentation { get; set;}
    public System.String Label { get; set;}
    public System.String Name { get; set;}
  public class SignatureHelpResult
    .ctor(System.Collections.Generic.IEnumerable<SignatureHelpItem> signatures = null, System.Collections.Generic.IEnumerable<SerializableDiagnostic> diagnostics = null, System.String requestId = null)
    public System.Int32 ActiveParameter { get; set;}
    public System.Int32 ActiveSignature { get; set;}
    public System.Collections.Generic.IEnumerable<SerializableDiagnostic> Diagnostics { get; set;}
    public System.String RequestId { get; set;}
    public System.Collections.Generic.IEnumerable<SignatureHelpItem> Signatures { get; set;}
  public class Workspace
    public static Workspace FromSource(System.String source, System.String workspaceType, System.String id = Program.cs, System.String[] usings = null, System.String language = csharp, System.Int32 position = 0)
    public static Workspace FromSources(System.String workspaceType = null, System.String language = csharp, System.ValueTuple<System.String,System.String,System.Int32> sources)
    .ctor(System.String[] usings = null, File[] files = null, Buffer[] buffers = null, System.String workspaceType = script, System.String language = csharp, System.Boolean includeInstrumentation = False)
    public Buffer[] Buffers { get;}
    public File[] Files { get;}
    public System.Boolean IncludeInstrumentation { get;}
    public System.String Language { get;}
    public System.String[] Usings { get;}
    public System.String WorkspaceType { get;}
  public class WorkspaceRequest
    .ctor(Workspace workspace, BufferId activeBufferId = null, HttpRequest httpRequest = null, System.Nullable<System.Int32> position = null, System.String requestId = null, System.String runArgs = )
    public BufferId ActiveBufferId { get;}
    public HttpRequest HttpRequest { get;}
    public System.String RequestId { get;}
    public System.String RunArgs { get;}
    public Workspace Workspace { get;}
Microsoft.DotNet.Interactive.CSharpProject.Servers
  public abstract class IWorkspaceServer, Microsoft.DotNet.Interactive.CSharpProject.ICodeCompiler, Microsoft.DotNet.Interactive.CSharpProject.ICodeRunner, Microsoft.DotNet.Interactive.CSharpProject.ILanguageService
  public class WorkspaceServerMultiplexer, Microsoft.DotNet.Interactive.CSharpProject.ICodeCompiler, Microsoft.DotNet.Interactive.CSharpProject.ICodeRunner, Microsoft.DotNet.Interactive.CSharpProject.ILanguageService, IWorkspaceServer
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder packageFinder)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompileResult> Compile(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompletionResult> GetCompletionList(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.DiagnosticResult> GetDiagnostics(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.SignatureHelpResult> GetSignatureHelp(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.RunResult> Run(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
Microsoft.DotNet.Interactive.CSharpProject.Servers.Roslyn
  public static class DocumentExtensions
    public static System.Boolean IsMatch(Microsoft.DotNet.Interactive.CSharpProject.Protocol.File file)
    public static System.Boolean IsMatch(Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.SourceFile source)
    public static System.Boolean IsMatch(System.String sourceName)
  public static class PackageExtensions
    public static System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Compilation> Compile(Microsoft.DotNet.Interactive.CSharpProject.Protocol.Workspace workspace, Clockwise.Budget budget, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId activeBufferId)
    public static System.Threading.Tasks.Task<System.ValueTuple<Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.Document>>> GetCompilation(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.SourceFile> sources, Microsoft.CodeAnalysis.SourceCodeKind sourceCodeKind, System.Collections.Generic.IEnumerable<System.String> defaultUsings, System.Func<System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace>> workspaceFactory, Clockwise.Budget budget)
    public static System.Threading.Tasks.Task<System.ValueTuple<Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Project>> GetCompilation(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.SourceFile> sources, Microsoft.CodeAnalysis.SourceCodeKind sourceCodeKind, System.Collections.Generic.IEnumerable<System.String> defaultUsings, System.Func<System.Threading.Tasks.Task<Microsoft.CodeAnalysis.Workspace>> workspaceFactory, Clockwise.Budget budget)
    public static System.Threading.Tasks.Task<System.ValueTuple<Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.Project>> GetCompilationForLanguageServices(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.SourceFile> sources, Microsoft.CodeAnalysis.SourceCodeKind sourceCodeKind, System.Collections.Generic.IEnumerable<System.String> defaultUsings, Clockwise.Budget budget)
    public static System.Threading.Tasks.Task<System.ValueTuple<Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.Document>>> GetCompilationForRun(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.SourceFile> sources, Microsoft.CodeAnalysis.SourceCodeKind sourceCodeKind, System.Collections.Generic.IEnumerable<System.String> defaultUsings, Clockwise.Budget budget)
  public class RoslynWorkspaceServer, Microsoft.DotNet.Interactive.CSharpProject.ICodeCompiler, Microsoft.DotNet.Interactive.CSharpProject.ICodeRunner, Microsoft.DotNet.Interactive.CSharpProject.ILanguageService, Microsoft.DotNet.Interactive.CSharpProject.Servers.IWorkspaceServer
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackage package)
    .ctor(Microsoft.DotNet.Interactive.CSharpProject.Packaging.IPackageFinder packageRegistry)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompileResult> Compile(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.CompletionResult> GetCompletionList(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.DiagnosticResult> GetDiagnostics(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.SignatureHelpResult> GetSignatureHelp(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.RunResult> Run(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
  public static class WorkspaceUtilities
    public static System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.MetadataReference> GetMetadataReferences()
Microsoft.DotNet.Interactive.CSharpProject.Servers.Roslyn.Instrumentation
  public static class ArgumentListGenerator
    public static Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax GenerateArgumentListForGetProgramState(FilePosition filePosition, System.ValueTuple<System.Object,System.String> argumentList)
  public class Augmentation
    .ctor(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode associatedStatment, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> locals, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> fields, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> parameters, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> internalLocals, FilePosition position = null)
    public Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode AssociatedStatement { get;}
    public FilePosition CurrentFilePosition { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> Fields { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> InternalLocals { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> Locals { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.ISymbol> Parameters { get;}
    public Augmentation withPosition(FilePosition position)
  public class AugmentationMap
    .ctor(System.Collections.Generic.Dictionary<Microsoft.CodeAnalysis.SyntaxNode,Augmentation> data = null)
    .ctor(Augmentation[] augmentations)
    public System.Collections.Generic.Dictionary<Microsoft.CodeAnalysis.SyntaxNode,Augmentation> Data { get;}
  public static class EnumerableExtensions
    public static System.String Join<T>(System.String separator = ,)
  public class FilePosition
    .ctor()
    public System.Int64 Character { get; set;}
    public System.String File { get; set;}
    public System.Int64 Line { get; set;}
  public static class InstrumentationLineMapper
    public static System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.Viewport> FilterActiveViewport(System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.Viewport> viewports, Microsoft.DotNet.Interactive.CSharpProject.Protocol.BufferId activeBufferId)
    public static System.Threading.Tasks.Task<System.ValueTuple<AugmentationMap,VariableLocationMap>> MapLineLocationsRelativeToViewportAsync(AugmentationMap augmentationMap, VariableLocationMap locations, Microsoft.CodeAnalysis.Document document, Microsoft.DotNet.Interactive.CSharpProject.MLS.Project.Viewport viewport = null)
  public class InstrumentationMap
    .ctor(System.String fileToInstrument, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextSpan> instrumentationRegions)
    public System.String FileToInstrument { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextSpan> InstrumentationRegions { get;}
  public class InstrumentationSyntaxRewriter : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter
    public static Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax CreateSyntaxNode(FilePosition currentFilePosition, VariableInfo[] variables)
    .ctor(System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNode> instrumentedNodes, VariableLocationMap printOnce, AugmentationMap printEveryStep)
    public Microsoft.CodeAnalysis.SyntaxTree ApplyToTree(Microsoft.CodeAnalysis.SyntaxTree tree)
    public IEnumerable<TNode> AugmentWithInstrumentationStatements<TNode>(SyntaxList<TNode> list)
    public SyntaxList<TNode> VisitList<TNode>(SyntaxList<TNode> list)
  public class InstrumentationSyntaxVisitor : Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter
    .ctor(Microsoft.CodeAnalysis.Document document, Microsoft.CodeAnalysis.SemanticModel semanticModel, System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextSpan> replacementRegions = null)
    public AugmentationMap Augmentations { get;}
    public VariableLocationMap VariableLocations { get;}
    public Microsoft.CodeAnalysis.SyntaxNode VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax node)
    public Microsoft.CodeAnalysis.SyntaxNode VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax node)
    public Microsoft.CodeAnalysis.SyntaxNode VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax node)
  public static class InstrumentedOutputExtractor
    public static ProgramOutputStreams ExtractOutput(System.Collections.Generic.IReadOnlyCollection<System.String> outputLines)
  public static class LinePositionSpanExtensions
    public static System.Boolean ContainsLine(System.Int32 line)
  public class LineRange
    .ctor()
    public System.Int64 End { get; set;}
    public System.Int64 Start { get; set;}
  public class ProgramOutputStreams
    .ctor(System.Collections.Generic.IReadOnlyCollection<System.String> stdOut, System.Collections.Generic.IReadOnlyCollection<System.String> instrumentation, System.String programDescriptor = )
    public Microsoft.DotNet.Interactive.CSharpProject.Models.Instrumentation.ProgramDescriptor ProgramDescriptor { get;}
    public Microsoft.DotNet.Interactive.CSharpProject.Models.Instrumentation.ProgramStateAtPositionArray ProgramStatesArray { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.String> StdOut { get;}
  public class ProgramStateAtPosition
    .ctor()
    public VariableInfo[] Fields { get; set;}
    public FilePosition FilePosition { get; set;}
    public VariableInfo[] Locals { get; set;}
    public LineRange Output { get; set;}
    public VariableInfo[] Parameters { get; set;}
    public System.String StackTrace { get; set;}
  public static class TextSpanExtensions
    public static Microsoft.CodeAnalysis.Text.LinePositionSpan ToLinePositionSpan(Microsoft.CodeAnalysis.Text.SourceText text)
  public class VariableInfo
    .ctor()
    public System.String Name { get; set;}
    public LineRange RangeOfLines { get; set;}
    public Newtonsoft.Json.Linq.JToken Value { get; set;}
  public class VariableLocation
    public static VariableLocation FromSpan(Microsoft.CodeAnalysis.ISymbol variable, Microsoft.CodeAnalysis.Text.LinePositionSpan span)
    .ctor(Microsoft.CodeAnalysis.ISymbol variable, System.Int32 startLine, System.Int32 endLine, System.Int32 startColumn, System.Int32 endColumn)
    public System.Int32 EndColumn { get;}
    public System.Int32 EndLine { get;}
    public System.Int32 StartColumn { get;}
    public System.Int32 StartLine { get;}
    public Microsoft.CodeAnalysis.ISymbol Variable { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Int32 GetHashCode()
    public System.String Serialize()
    public Microsoft.CodeAnalysis.Text.LinePositionSpan ToLinePositionSpan()
  public class VariableLocationMap
    .ctor()
    public System.Void AddLocations(Microsoft.CodeAnalysis.ISymbol variable, System.Collections.Generic.IEnumerable<VariableLocation> locations)
    public System.String Serialize()
    public System.String SerializeForKey(Microsoft.CodeAnalysis.ISymbol key)
Microsoft.DotNet.Interactive.CSharpProject.Servers.Scripting
  public class ScriptingWorkspaceServer, Microsoft.DotNet.Interactive.CSharpProject.ICodeRunner
    .ctor()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.CSharpProject.Protocol.RunResult> Run(Microsoft.DotNet.Interactive.CSharpProject.Protocol.WorkspaceRequest request, Clockwise.Budget budget = null)
Microsoft.DotNet.Interactive.CSharpProject.Tools
  public class AsyncLazy<T>
    .ctor(Func<Task<T>> initialize)
    public Task<T> ValueAsync()
  public static class DirectoryAccessor
    public static System.Boolean DirectoryExists(System.String relativePath)
    public static System.Void EnsureDirectoryExists(System.String relativePath)
    public static System.Void EnsureRootDirectoryExists()
    public static System.Boolean FileExists(System.String relativePath)
    public static IDirectoryAccessor GetDirectoryAccessorFor(System.IO.DirectoryInfo directoryInfo)
    public static IDirectoryAccessor GetDirectoryAccessorForRelativePath(System.String relativePath)
    public static System.IO.DirectoryInfo GetFullyQualifiedDirectoryPath(RelativeDirectoryPath relativePath)
    public static System.IO.FileInfo GetFullyQualifiedFilePath(System.String relativeFilePath)
    public static System.IO.FileInfo GetFullyQualifiedFilePath(RelativeFilePath relativePath)
    public static System.IO.DirectoryInfo GetFullyQualifiedRoot()
    public static System.String ReadAllText(System.String relativePath)
    public static System.Boolean RootDirectoryExists()
    public static System.Void WriteAllText(System.String relativePath, System.String text)
  public static class DirectoryInfoExtensions
    public static System.Void CopyTo(System.IO.DirectoryInfo destination, System.Func<System.IO.FileSystemInfo,System.Boolean> skipWhen = null)
    public static System.IO.FileInfo File(System.String name)
    public static System.IO.DirectoryInfo NormalizeEnding()
    public static System.IO.DirectoryInfo Subdirectory(System.String path)
  public static class FileInfoExtensions
    public static System.Boolean IsBuildOutput()
    public static System.String Read()
    public static System.Threading.Tasks.Task<System.String> ReadAsync()
  public class FileSystemDirectoryAccessor, IDirectoryAccessor
    .ctor(System.String directory)
    .ctor(System.IO.DirectoryInfo rootDir)
    public System.Boolean DirectoryExists(RelativeDirectoryPath path)
    public System.Void EnsureDirectoryExists(RelativeDirectoryPath path)
    public System.Boolean FileExists(RelativeFilePath filePath)
    public System.Collections.Generic.IEnumerable<RelativeDirectoryPath> GetAllDirectoriesRecursively()
    public System.Collections.Generic.IEnumerable<RelativeFilePath> GetAllFiles()
    public System.Collections.Generic.IEnumerable<RelativeFilePath> GetAllFilesRecursively()
    public IDirectoryAccessor GetDirectoryAccessorForRelativePath(RelativeDirectoryPath relativePath)
    public System.IO.FileSystemInfo GetFullyQualifiedPath(RelativePath path)
    public System.String ReadAllText(RelativeFilePath filePath)
    public System.String ToString()
    public System.Void WriteAllText(RelativeFilePath path, System.String text)
  public abstract class IDirectoryAccessor
    public System.Boolean DirectoryExists(RelativeDirectoryPath path)
    public System.Void EnsureDirectoryExists(RelativeDirectoryPath path)
    public System.Boolean FileExists(RelativeFilePath path)
    public System.Collections.Generic.IEnumerable<RelativeDirectoryPath> GetAllDirectoriesRecursively()
    public System.Collections.Generic.IEnumerable<RelativeFilePath> GetAllFiles()
    public System.Collections.Generic.IEnumerable<RelativeFilePath> GetAllFilesRecursively()
    public IDirectoryAccessor GetDirectoryAccessorForRelativePath(RelativeDirectoryPath path)
    public System.IO.FileSystemInfo GetFullyQualifiedPath(RelativePath path)
    public System.String ReadAllText(RelativeFilePath path)
    public System.Void WriteAllText(RelativeFilePath path, System.String text)
  public class RelativeDirectoryPath : RelativePath, System.IEquatable<RelativeDirectoryPath>
    public static RelativeDirectoryPath Root { get;}
    public static System.Boolean op_Equality(RelativeDirectoryPath left, RelativeDirectoryPath right)
    public static System.Boolean op_Inequality(RelativeDirectoryPath left, RelativeDirectoryPath right)
    .ctor(System.String value)
    public System.Boolean Equals(RelativeDirectoryPath other)
    public System.Boolean Equals(System.Object obj)
    public System.Int32 GetHashCode()
  public class RelativeFilePath : RelativePath, System.IEquatable<RelativeFilePath>
    public static System.Boolean TryParse(System.String path, ref RelativeFilePath& relativeFilePath)
    .ctor(System.String value)
    public RelativeDirectoryPath Directory { get;}
    public System.String Extension { get;}
    public System.String FileName { get;}
    public System.Boolean Equals(RelativeFilePath other)
    public System.Boolean Equals(System.Object obj)
    public System.Int32 GetHashCode()
  public abstract class RelativePath
    public static System.String NormalizeDirectory(System.String directoryPath)
    public System.String Value { get;}
    protected System.Void set_Value(System.String value)
    public System.String ToString()
  public static class RelativePathExtensions
    public static System.IO.FileInfo Combine(RelativeFilePath filePath)
    public static System.IO.DirectoryInfo Combine(RelativeDirectoryPath directoryPath)
    public static T Match<T>(Func<RelativeDirectoryPath,T> directory, Func<RelativeFilePath,T> file)
  public static class TypeExtensions
    public static System.String ReadManifestResource(System.String resourceName)
Microsoft.DotNet.Interactive.CSharpProject.Transformations
  public static class DiagnosticTransformer
    public static System.Collections.Generic.IReadOnlyCollection<Microsoft.CodeAnalysis.Diagnostic> RemoveSuppressed()
Microsoft.DotNet.Interactive.CSharpProject.Utility
  public class ConsoleOutput, System.IDisposable
    public static System.Threading.Tasks.Task<ConsoleOutput> Capture()
    public System.String StandardError { get;}
    public System.String StandardOutput { get;}
    public System.Void Clear()
    public System.Void Dispose()
    public System.Boolean IsEmpty()
    public System.IDisposable SubscribeToStandardError(System.Action<System.String> action)
    public System.IDisposable SubscribeToStandardOutput(System.Action<System.String> action)
  public static class DirectoryUtility
    public static System.IO.DirectoryInfo CreateDirectory(System.String folderNameStartsWith = null, System.IO.DirectoryInfo parentDirectory = null)
    public static System.Void DeleteFileSystemObject()
    public static System.Void Populate(System.ValueTuple<System.String,System.String> contents)
  public class Dotnet2
    public static System.IO.FileInfo Path { get;}
    public static System.String GetDataFromAppDomain(System.String propertyName)
    .ctor(System.IO.DirectoryInfo workingDirectory = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.AddPackageResult> AddPackage(System.String packageId, System.String version = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> AddReference(System.IO.FileInfo projectToReference)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> Build(System.String args = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> Clean()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> Execute(System.String args)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> New(System.String templateName, System.String args = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> Pack(System.String args = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> Publish(System.String args = null)
    public System.Diagnostics.Process StartProcess(System.String args, System.Action<System.String> output = null, System.Action<System.String> error = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> ToolInstall(System.String packageName, System.IO.DirectoryInfo toolPath, System.String addSource = null, System.String version = null)
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.String>> ToolList(System.IO.DirectoryInfo directory)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Utility.CommandLineResult> VSTest(System.String args)
  public static class PathUtilities2
    public static System.String ChangeExtension(System.String path, System.String extension)
    public static System.String CombineAbsoluteAndRelativePaths(System.String root, System.String relativePath)
    public static System.String CombinePathsUnchecked(System.String root, System.String relativePath)
    public static System.String CombinePossiblyRelativeAndRelativePaths(System.String rootOpt, System.String relativePath)
    public static System.Boolean ContainsPathComponent(System.String path, System.String component, System.Boolean ignoreCase)
    public static System.String EnsureTrailingSeparator()
    public static System.String GetDirectoryName(System.String path)
    public static System.String GetExtension(System.String path)
    public static System.String GetFileName(System.String path, System.Boolean includeExtension = True)
    public static Microsoft.DotNet.Interactive.Utility.PathKind GetPathKind(System.String path)
    public static System.String GetPathRoot(System.String path)
    public static System.String GetRelativePath(System.String directory, System.String fullPath)
    public static System.Boolean IsAbsolute(System.String path)
    public static System.Boolean IsAnyDirectorySeparator(System.Char c)
    public static System.Boolean IsChildPath(System.String parentPath, System.String childPath)
    public static System.Boolean IsDirectorySeparator(System.Char c)
    public static System.Boolean IsFilePath(System.String assemblyDisplayNameOrPath)
    public static System.Boolean IsValidFilePath(System.String fullPath)
    public static System.String NormalizePathPrefix(System.String filePath, System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<System.String,System.String>> pathMap)
    public static System.Boolean PathsEqual(System.String path1, System.String path2)
    public static System.String RemoveExtension(System.String path)
Microsoft.DotNet.Interactive.CSharpProject.WorkspaceFeatures
  public abstract class CommandLineObservable, System.IObservable<System.String>
    public System.IDisposable Subscribe(System.IObserver<System.String> observer)
  public class StandardError : CommandLineObservable, System.IObservable<System.String>
    .ctor()
  public class StandardOutput : CommandLineObservable, System.IObservable<System.String>
    .ctor()
  public class UnitTestResult
    .ctor()
  public class UnitTestRun, Microsoft.DotNet.Interactive.CSharpProject.Protocol.IRunResultFeature
    .ctor(System.Collections.Generic.IEnumerable<UnitTestResult> results)
    public System.String Name { get;}
    public System.Collections.Generic.IEnumerable<UnitTestResult> Results { get;}
    public System.Void Apply(Microsoft.DotNet.Interactive.CSharpProject.Protocol.FeatureContainer result)
Recipes
  public static class ConfirmationLoggerExtensions
