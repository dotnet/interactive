Microsoft.DotNet.Interactive
  public class AutomationEnvironment : FrontendEnvironment
    .ctor()
  public class ChooseKernelDirective : System.CommandLine.Command, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.ICommand, System.CommandLine.IIdentifierSymbol, System.CommandLine.ISymbol, System.CommandLine.Suggestions.ISuggestionSource
    .ctor(Kernel kernel, System.String description = null)
    public Kernel Kernel { get;}
    protected System.Threading.Tasks.Task Handle(KernelInvocationContext kernelInvocationContext, System.CommandLine.Invocation.InvocationContext commandLineInvocationContext)
  public class ChooseKeyValueStoreKernelDirective : ChooseKernelDirective, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.ICommand, System.CommandLine.IIdentifierSymbol, System.CommandLine.ISymbol, System.CommandLine.Suggestions.ISuggestionSource
    .ctor(Kernel kernel)
    public System.CommandLine.Option<System.IO.FileInfo> FromFileOption { get;}
    public System.CommandLine.Option<System.Uri> FromUrlOption { get;}
    public System.CommandLine.Option<System.String> MimeTypeOption { get;}
    public System.CommandLine.Option<System.String> NameOption { get;}
    protected System.Threading.Tasks.Task Handle(KernelInvocationContext kernelInvocationContext, System.CommandLine.Invocation.InvocationContext commandLineInvocationContext)
  public class CodeSubmissionCompilationErrorException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.Exception innerException)
  public class CompositeKernel : Kernel, Microsoft.DotNet.Interactive.Extensions.IExtensibleKernel, System.Collections.Generic.IEnumerable<Kernel>, System.Collections.IEnumerable, System.IDisposable
    .ctor()
    public System.Collections.Generic.IReadOnlyList<Kernel> ChildKernels { get;}
    public System.String DefaultKernelName { get; set;}
    public KernelHost Host { get;}
    public System.Void Add(Kernel kernel, System.Collections.Generic.IReadOnlyCollection<System.String> aliases = null)
    public System.Void AddKernelConnection<TOptions>(ConnectKernelCommand<TOptions> connectionCommand)
     System.Collections.Generic.IEnumerable<System.CommandLine.Parsing.Parser> GetDirectiveParsersForCompletion(Microsoft.DotNet.Interactive.Parsing.DirectiveNode directiveNode, System.Int32 requestPosition)
    public System.Collections.Generic.IEnumerator<Kernel> GetEnumerator()
     SchedulingScope GetHandlingKernelCommandScope(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
     System.String GetHandlingKernelName(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
    public System.Threading.Tasks.Task LoadExtensionsFromDirectoryAsync(System.IO.DirectoryInfo directory, KernelInvocationContext context)
    protected System.Void SetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public class DataDictionaryConverter : JsonConverter<System.Collections.Generic.IDictionary<System.String,System.Object>>
    .ctor()
    public System.Collections.Generic.IDictionary<System.String,System.Object> Read(ref System.Text.Json.Utf8JsonReader& reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
  public static class DataExplorer
    public static DataExplorer<TData> Create<TData>(System.String dataExplorerTypeName, TData data)
    public static DataExplorer<TData> CreateDefault<TData>(TData data)
    public static System.Void Register(System.Type dataType, System.Type dataExplorerType)
    public static System.Void Register<TData, TExplorer>()
    public static System.Void ResetToDefault()
    public static System.Void SetDefault<TData, TExplorer>()
  public abstract class DataExplorer<TData>
    public static System.Void Register<TDataExplorer>()
    public static System.Void RegisterFormatters()
    public TData Data { get;}
    public System.String Id { get;}
    protected Microsoft.AspNetCore.Html.IHtmlContent ToHtml()
  public class Diagnostic
    public static Diagnostic FromCodeAnalysisDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic)
    .ctor(LinePositionSpan linePositionSpan, Microsoft.CodeAnalysis.DiagnosticSeverity severity, System.String code, System.String message)
    public System.String Code { get;}
    public LinePositionSpan LinePositionSpan { get;}
    public System.String Message { get;}
    public Microsoft.CodeAnalysis.DiagnosticSeverity Severity { get;}
    public System.String ToString()
    public Diagnostic WithLinePositionSpan(LinePositionSpan linePositionSpan)
  public class DisplayedValue
    .ctor(System.String displayId, System.String mimeType, KernelInvocationContext context)
    .ctor(System.String displayId, System.String[] mimeTypes, KernelInvocationContext context)
    public System.Collections.Generic.IReadOnlyCollection<System.String> MimeTypes { get;}
    public System.Void Update(System.Object updatedValue)
  public static class DotNetKernelExtensions
    public static System.Threading.Tasks.Task SetValueAsync<T>(System.String name, T value)
  public class FormattedValue
    public static System.Collections.Generic.IReadOnlyCollection<FormattedValue> FromObject(System.Object value, System.String[] mimeTypes)
    .ctor(System.String mimeType, System.String value)
    public System.String MimeType { get;}
    public System.String Value { get;}
  public abstract class FrontendEnvironment
    public System.Boolean AllowStandardInput { get; set;}
    public System.Threading.Tasks.Task ExecuteClientScript(System.String code, KernelInvocationContext context)
  public class HtmlKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SubmitCode command, KernelInvocationContext context)
  public abstract class IKernelCommandHandler<TCommand>
    public System.Threading.Tasks.Task HandleAsync(TCommand command, KernelInvocationContext context)
  public abstract class IKernelExtension
    public System.Threading.Tasks.Task OnLoadAsync(Kernel kernel)
  public abstract class IKernelExtensionLoader
    public System.Threading.Tasks.Task LoadFromDirectoryAsync(System.IO.DirectoryInfo directory, Kernel kernel, KernelInvocationContext context)
  public abstract class IKernelScheduler<T,TResult>
    public Task<TResult> RunAsync(T value, KernelSchedulerDelegate<T,TResult> onExecuteAsync, System.String scope = default, System.Threading.CancellationToken cancellationToken = null)
  public class InstallPackagesMessage
    .ctor(System.Collections.Generic.IReadOnlyList<System.String> restoreSources, System.Collections.Generic.IReadOnlyList<System.String> installingPackages, System.Collections.Generic.IReadOnlyList<System.String> installedPackages, System.Int32 progress)
    public System.Collections.Generic.IReadOnlyList<System.String> InstalledPackages { get; set;}
    public System.Collections.Generic.IReadOnlyList<System.String> InstallingPackages { get; set;}
    public System.Int32 Progress { get; set;}
    public System.Collections.Generic.IReadOnlyList<System.String> RestoreSources { get; set;}
    public System.String FormatAsHtml()
    public System.String FormatAsPlainText()
    public System.Collections.Generic.IEnumerable<System.String> FormatAsPlainTextLines()
  public abstract class IStaticContentSource
    public System.String Name { get;}
  public class JavaScriptKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor(Microsoft.DotNet.Interactive.Connection.KernelClientBase client = null)
    protected Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> CreateDefaultHandlerForCommandType<TCommand>()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SubmitCode command, KernelInvocationContext context)
  public abstract class JsonConverter<T> : JsonConverter<T>
    protected System.Void EnsureStartObject(System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert)
    protected System.Void OnWrite(System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options)
    public System.Void Write(System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options)
  public abstract class Kernel, System.IDisposable
    public static Kernel Current { get;}
    public static Kernel Root { get;}
    public static System.Void CSS(System.String content)
    public static DisplayedValue display(System.Object value, System.String[] mimeTypes)
    public static Microsoft.AspNetCore.Html.IHtmlContent HTML(System.String content)
    public static System.Void Javascript(System.String scriptContent)
    public ChooseKernelDirective ChooseKernelDirective { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.CommandLine.ICommand> Directives { get;}
    public FrontendEnvironment FrontendEnvironment { get; set;}
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public System.String Name { get;}
    public CompositeKernel ParentKernel { get;}
    public Kernel RootKernel { get;}
    public Microsoft.DotNet.Interactive.Parsing.SubmissionParser SubmissionParser { get;}
    public System.Void AddDirective(System.CommandLine.Command command)
    public System.Void AddMiddleware(KernelCommandPipelineMiddleware middleware, System.String caller = null)
    protected Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> CreateDefaultHandlerForCommandType<TCommand>()
    public System.Void DeferCommand(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
     System.Void DelegatePublication(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent)
    public System.Void Dispose()
    protected System.Boolean get_IsDisposed()
     KernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult> get_Scheduler()
    protected System.CommandLine.Parsing.ParseResult get_SelectorParserResults()
    protected System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Commands.KernelCommand> GetDeferredOperations(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.String scope)
     System.Collections.Generic.IEnumerable<System.CommandLine.Parsing.Parser> GetDirectiveParsersForCompletion(Microsoft.DotNet.Interactive.Parsing.DirectiveNode directiveNode, System.Int32 requestPosition)
     SchedulingScope GetHandlingKernelCommandScope(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext invocationContext)
     System.String GetHandlingKernelName(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext invocationContext)
    public Microsoft.DotNet.Interactive.ValueSharing.IKernelValueDeclarer GetValueDeclarer(System.Object value)
     System.Void PublishEvent(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent)
    public System.Void RegisterCommandHandler<TCommand>(Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> handler)
    public System.Void RegisterCommandType<TCommand>()
    public System.Void RegisterForDisposal(System.Action dispose)
    public System.Void RegisterForDisposal(System.IDisposable disposable)
    public System.Threading.Tasks.Task<KernelCommandResult> SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Threading.CancellationToken cancellationToken)
     System.Void set_SelectorParserResults(System.CommandLine.Parsing.ParseResult value)
    protected System.Void SetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
     System.Void SetScheduler(KernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult> scheduler)
    public System.Collections.Generic.IEnumerable<System.Type> SupportedCommands()
    public System.Boolean SupportsCommand<T>()
     System.Void TrySetHandler(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public static class KernelCommandExtensions
    public static System.String GetOrCreateToken()
    public static System.Void PublishInternalEvents()
    public static System.Void SetToken(System.String token)
  public delegate KernelCommandInvocation : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public delegate KernelCommandPipelineMiddleware : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next)
  public class KernelCommandResult
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
  public class KernelException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.String message)
  public class KernelExtensionLoadException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.Exception innerException)
  public static class KernelExtensions
    public static Kernel FindKernel(System.String name)
    public static T LogCommandsToPocketLogger<T>()
    public static T LogEventsToPocketLogger<T>()
    public static System.Threading.Tasks.Task<KernelCommandResult> SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static System.Threading.Tasks.Task ShareValue(Kernel toKernel, System.String valueName)
    public static System.Collections.Generic.IEnumerable<Kernel> Subkernels(System.Boolean recursive = False)
    public static System.Collections.Generic.IEnumerable<Kernel> SubkernelsAndSelf(System.Boolean recursive = False)
    public static System.Threading.Tasks.Task<KernelCommandResult> SubmitCodeAsync(System.String code)
    public static CompositeKernel UseKernelClientConnection<TConnector>(ConnectKernelCommand<TConnector> command)
    public static T UseLogMagicCommand<T>()
    public static T UseQuitCommand<T>(System.Func<System.Threading.Tasks.Task> onQuitAsync = null)
    public static Microsoft.DotNet.Interactive.Connection.ProxyKernel UseValueSharing(Microsoft.DotNet.Interactive.ValueSharing.IKernelValueDeclarer kernelValueDeclarer)
    public static T UseValueSharing<T>()
    public static TKernel UseWho<TKernel>()
    public static System.Void VisitSubkernels(System.Action<Kernel> onVisit, System.Boolean recursive = False)
    public static System.Void VisitSubkernelsAndSelf(System.Action<Kernel> onVisit, System.Boolean recursive = False)
    public static System.Threading.Tasks.Task VisitSubkernelsAndSelfAsync(System.Func<Kernel,System.Threading.Tasks.Task> onVisit, System.Boolean recursive = False)
    public static System.Threading.Tasks.Task VisitSubkernelsAsync(System.Func<Kernel,System.Threading.Tasks.Task> onVisit, System.Boolean recursive = False)
  public class KernelHost, System.IDisposable
    public static KernelHost InProcess(CompositeKernel kernel)
    .ctor(CompositeKernel kernel, Microsoft.DotNet.Interactive.Connection.IKernelCommandAndEventSender defaultSender, Microsoft.DotNet.Interactive.Connection.MultiplexingKernelCommandAndEventReceiver defaultReceiver, System.Uri hostUri)
    .ctor(CompositeKernel kernel, Microsoft.DotNet.Interactive.Connection.IKernelCommandAndEventSender defaultSender, Microsoft.DotNet.Interactive.Connection.MultiplexingKernelCommandAndEventReceiver defaultReceiver)
    public System.Uri Uri { get;}
    public System.Threading.Tasks.Task ConnectAndWaitAsync()
    public System.Threading.Tasks.Task ConnectAsync()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Connection.ProxyKernel> CreateProxyKernelOnDefaultConnectorAsync(KernelInfo kernelInfo)
    public System.Void Dispose()
    public System.Boolean TryGetKernelByDestinationUri(System.Uri destinationUri, ref Kernel& kernel)
    public System.Boolean TryGetKernelByOriginUri(System.Uri originUri, ref Kernel& kernel)
    public System.Boolean TryGetKernelInfo(Kernel kernel, ref KernelInfo& kernelInfo)
  public class KernelInfo
    .ctor(System.String localName, System.Collections.Generic.IReadOnlyCollection<System.String> aliases = null, System.Uri destinationUri = null)
    public System.Collections.Generic.IReadOnlyCollection<System.String> Aliases { get;}
    public System.Uri DestinationUri { get;}
    public System.String LocalName { get;}
    public System.Uri OriginUri { get;}
    public System.String ToString()
  public class KernelInvocationContext, System.IAsyncDisposable
    public static KernelInvocationContext Current { get;}
    public static KernelInvocationContext Establish(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.Threading.CancellationToken CancellationToken { get;}
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public Kernel HandlingKernel { get;}
    public System.Boolean IsComplete { get;}
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public KernelCommandResult Result { get;}
    public System.Void Complete(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.Threading.Tasks.ValueTask DisposeAsync()
    public System.Void Fail(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Exception exception = null, System.String message = null)
    public System.Void OnComplete(System.Func<KernelInvocationContext,System.Threading.Tasks.Task> onComplete)
    public System.Void Publish(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public System.Threading.Tasks.Task ScheduleAsync(System.Func<KernelInvocationContext,System.Threading.Tasks.Task> func)
  public static class KernelInvocationContextExtensions
    public static DisplayedValue Display(System.Object value, System.String[] mimeTypes)
    public static DisplayedValue DisplayAs(System.String value, System.String mimeType, System.String[] additionalMimeTypes)
    public static System.Void DisplayStandardError(System.String error, Microsoft.DotNet.Interactive.Commands.KernelCommand command = null)
    public static System.Void DisplayStandardOut(System.String output, Microsoft.DotNet.Interactive.Commands.KernelCommand command = null)
  public delegate KernelPipelineContinuation : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public class KernelScheduler<T,TResult>, IKernelScheduler<T,TResult>, System.IDisposable
    .ctor()
    public System.Void CancelCurrentOperation(Action<T> onCancellation = null)
    public System.Void Dispose()
    public System.Void RegisterDeferredOperationSource(GetDeferredOperationsDelegate getDeferredOperations, KernelSchedulerDelegate<T,TResult> kernelSchedulerOnExecuteAsync)
    public Task<TResult> RunAsync(T value, KernelSchedulerDelegate<T,TResult> onExecuteAsync, System.String scope = default, System.Threading.CancellationToken cancellationToken = null)
   delegate GetDeferredOperationsDelegate : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(T operationToExecute, System.String queueName, System.AsyncCallback callback, System.Object object)
    public IReadOnlyList<T> EndInvoke(System.IAsyncResult result)
    public IReadOnlyList<T> Invoke(T operationToExecute, System.String queueName)
  public delegate KernelSchedulerDelegate<T,TResult> : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(T value, System.AsyncCallback callback, System.Object object)
    public Task<TResult> EndInvoke(System.IAsyncResult result)
    public Task<TResult> Invoke(T value)
  public class KeyValueStoreKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, Microsoft.DotNet.Interactive.ValueSharing.ISupportGetValue, Microsoft.DotNet.Interactive.ValueSharing.ISupportSetClrValue, System.IDisposable
    .ctor()
    public ChooseKernelDirective ChooseKernelDirective { get;}
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo> GetValueInfos()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SubmitCode command, KernelInvocationContext context)
    public System.Threading.Tasks.Task SetValueAsync(System.String name, System.Object value, System.Type declaredType = null)
    public System.Boolean TryGetValue<T>(System.String name, ref T& value)
  public class KqlDiscoverabilityKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SubmitCode command, KernelInvocationContext context)
  public class LinePosition, System.IEquatable<LinePosition>
    public static LinePosition FromCodeAnalysisLinePosition(Microsoft.CodeAnalysis.Text.LinePosition linePosition)
    public static System.Boolean op_Equality(LinePosition a, LinePosition b)
    public static System.Boolean op_Inequality(LinePosition a, LinePosition b)
    .ctor(System.Int32 line, System.Int32 character)
    public System.Int32 Character { get;}
    public System.Int32 Line { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(LinePosition other)
    public System.Int32 GetHashCode()
    public LinePosition SubtractLineOffset(LinePosition offset)
    public Microsoft.CodeAnalysis.Text.LinePosition ToCodeAnalysisLinePosition()
    public System.String ToString()
  public class LinePositionSpan, System.IEquatable<LinePositionSpan>
    public static LinePositionSpan FromCodeAnalysisLinePositionSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan linePositionSpan)
    public static System.Boolean op_Equality(LinePositionSpan a, LinePositionSpan b)
    public static System.Boolean op_Inequality(LinePositionSpan a, LinePositionSpan b)
    .ctor(LinePosition start, LinePosition end)
    public LinePosition End { get;}
    public LinePosition Start { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(LinePositionSpan other)
    public System.Int32 GetHashCode()
    public LinePositionSpan SubtractLineOffset(LinePosition offset)
    public System.String ToString()
  public class NoSuitableKernelException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
  public class PackageReference
    public static System.Boolean TryParse(System.String value, ref PackageReference& reference)
    .ctor(System.String packageName, System.String packageVersion = null)
    public System.Boolean IsPackageVersionSpecified { get;}
    public System.String PackageName { get;}
    public System.String PackageVersion { get;}
    public System.String ToString()
  public class PackageReferenceOrFileInfo
    public static PackageReferenceOrFileInfo op_Implicit(System.IO.FileInfo source)
    public static PackageReferenceOrFileInfo op_Implicit(PackageReference source)
    .ctor(System.IO.FileInfo fileInfo)
    .ctor(PackageReference packageReference)
    public System.IO.FileInfo FileInfo { get;}
    public PackageReference PackageReference { get;}
    public System.Object Value { get;}
  public class ParameterInformation
    .ctor(System.String label, FormattedValue documentation)
    public FormattedValue Documentation { get;}
    public System.String Label { get;}
  public class PasswordString
    .ctor(System.String clearTextPassword)
    public System.String GetClearTextPassword()
  public class ResolvedPackageReference : PackageReference
    .ctor(System.String packageName, System.String packageVersion, System.Collections.Generic.IReadOnlyList<System.String> assemblyPaths, System.String packageRoot = null, System.Collections.Generic.IReadOnlyList<System.String> probingPaths = null)
    public System.Collections.Generic.IReadOnlyList<System.String> AssemblyPaths { get;}
    public System.String PackageRoot { get;}
    public System.Collections.Generic.IReadOnlyList<System.String> ProbingPaths { get;}
    public System.String ToString()
  public class ScriptContent, Microsoft.AspNetCore.Html.IHtmlContent
    .ctor(System.String scriptValue)
    public System.String ScriptValue { get;}
    public System.Void WriteTo(System.IO.TextWriter writer, System.Text.Encodings.Web.HtmlEncoder encoder)
  public class SignatureInformation
    .ctor(System.String label, FormattedValue documentation, System.Collections.Generic.IReadOnlyList<ParameterInformation> parameters)
    public FormattedValue Documentation { get;}
    public System.String Label { get;}
    public System.Collections.Generic.IReadOnlyList<ParameterInformation> Parameters { get;}
  public class SqlDiscoverabilityKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SubmitCode command, KernelInvocationContext context)
  public class TabularDataResourceSummaryExplorer : DataExplorer<Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResource>
    .ctor(Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResource data)
    protected Microsoft.AspNetCore.Html.IHtmlContent ToHtml()
Microsoft.DotNet.Interactive.Commands
  public class AddPackage : KernelCommand
    .ctor(Microsoft.DotNet.Interactive.PackageReference packageReference)
    public Microsoft.DotNet.Interactive.PackageReference PackageReference { get;}
  public class Cancel : KernelCommand
    .ctor(System.String targetKernelName = null)
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class ChangeWorkingDirectory : KernelCommand
    .ctor(System.String workingDirectory)
    public System.String WorkingDirectory { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class DisplayError : KernelCommand
    .ctor(System.String message)
    public System.String Message { get;}
  public class DisplayValue : KernelCommand
    .ctor(Microsoft.DotNet.Interactive.FormattedValue formattedValue, System.String valueId = null)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String ValueId { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public abstract class KernelCommand
    public Microsoft.DotNet.Interactive.KernelCommandInvocation Handler { get; set;}
    public System.CommandLine.Parsing.ParseResult KernelChooserParseResult { get;}
    public KernelCommand Parent { get;}
    public System.Collections.Generic.IDictionary<System.String,System.Object> Properties { get;}
    public System.Nullable<System.Boolean> ShouldPublishCompletionEvent { get;}
    public System.String TargetKernelName { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
     System.Void set_ShouldPublishCompletionEvent(System.Nullable<System.Boolean> value)
  public abstract class LanguageServiceCommand : KernelCommand
    public System.String Code { get;}
    public Microsoft.DotNet.Interactive.LinePosition LinePosition { get;}
    protected System.Void set_Code(System.String value)
    protected System.Void set_LinePosition(Microsoft.DotNet.Interactive.LinePosition value)
  public class Quit : KernelCommand
    .ctor()
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class RequestCompletions : LanguageServiceCommand
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestDiagnostics : KernelCommand
    .ctor(System.String code, System.String targetKernelName = null)
    public System.String Code { get;}
  public class RequestHoverText : LanguageServiceCommand
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestSignatureHelp : LanguageServiceCommand
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestValue : KernelCommand
    .ctor(System.String name, System.String targetKernelName, System.String mimeType = null)
    public System.String MimeType { get;}
    public System.String Name { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class RequestValueInfos : KernelCommand
    .ctor(System.String targetKernelName)
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class SendEditableCode : KernelCommand
    .ctor(System.String language, System.String code, System.String targetKernelName = vscode)
    public System.String Code { get;}
    public System.String Language { get;}
  public enum SubmissionType : System.Enum, System.IComparable, System.IConvertible, System.IFormattable
    Run=0
    Diagnose=1
  public class SubmitCode : KernelCommand
    .ctor(System.String code, System.String targetKernelName = null, SubmissionType submissionType = Run)
    public System.String Code { get;}
    public SubmissionType SubmissionType { get;}
    public System.String ToString()
  public class UpdateDisplayedValue : KernelCommand
    .ctor(Microsoft.DotNet.Interactive.FormattedValue formattedValue, System.String valueId)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String ValueId { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
Microsoft.DotNet.Interactive.Connection
  public class CommandOrEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand)
    .ctor(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Boolean isParseError = False)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public Microsoft.DotNet.Interactive.Events.KernelEvent Event { get;}
    public System.Boolean IsParseError { get;}
  public abstract class ConnectKernelCommand<TConnector> : System.CommandLine.Command, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.ICommand, System.CommandLine.IIdentifierSymbol, System.CommandLine.ISymbol, System.CommandLine.Suggestions.ISuggestionSource
    public System.String ConnectedKernelDescription { get; set;}
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo, TConnector connection, Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class ConnectNamedPipeCommand : ConnectKernelCommand<NamedPipeKernelConnector>, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.ICommand, System.CommandLine.IIdentifierSymbol, System.CommandLine.ISymbol, System.CommandLine.Suggestions.ISuggestionSource
    .ctor()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo, NamedPipeKernelConnector connector, Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class ConnectStdIoCommand : ConnectKernelCommand<StdIoKernelConnector>, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.ICommand, System.CommandLine.IIdentifierSymbol, System.CommandLine.ISymbol, System.CommandLine.Suggestions.ISuggestionSource
    .ctor()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo, StdIoKernelConnector kernelConnector, Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public abstract class IKernelCommandAndEventReceiver
    public System.Collections.Generic.IAsyncEnumerable<CommandOrEvent> CommandsAndEventsAsync(System.Threading.CancellationToken cancellationToken)
  public abstract class IKernelCommandAndEventSender
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand, System.Threading.CancellationToken cancellationToken)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Threading.CancellationToken cancellationToken)
  public abstract class IKernelConnector
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo)
  public abstract class InteractiveProtocolKernelCommandAndEventReceiverBase : KernelCommandAndEventReceiverBase, IKernelCommandAndEventReceiver
    protected System.Threading.Tasks.Task<CommandOrEvent> ReadCommandOrEventAsync(System.Threading.CancellationToken cancellationToken)
    protected System.Threading.Tasks.Task<System.String> ReadMessageAsync(System.Threading.CancellationToken cancellationToken)
  public abstract class KernelClientBase
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.String token = null)
  public class KernelCommandAndEventObservableReceiver : InteractiveProtocolKernelCommandAndEventReceiverBase, IKernelCommandAndEventReceiver, System.IDisposable
    .ctor(System.IObservable<System.String> receiver)
    public System.Void Dispose()
    protected System.Threading.Tasks.Task<System.String> ReadMessageAsync(System.Threading.CancellationToken cancellationToken)
  public class KernelCommandAndEventPipeStreamReceiver : InteractiveProtocolKernelCommandAndEventReceiverBase, IKernelCommandAndEventReceiver
    .ctor(System.IO.Pipes.PipeStream reader)
    protected System.Threading.Tasks.Task<System.String> ReadMessageAsync(System.Threading.CancellationToken cancellationToken)
  public class KernelCommandAndEventPipeStreamSender, IKernelCommandAndEventSender
    .ctor(System.IO.Pipes.PipeStream sender)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand, System.Threading.CancellationToken cancellationToken)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Threading.CancellationToken cancellationToken)
  public abstract class KernelCommandAndEventReceiverBase, IKernelCommandAndEventReceiver
    public System.Collections.Generic.IAsyncEnumerable<CommandOrEvent> CommandsAndEventsAsync(System.Threading.CancellationToken cancellationToken)
    protected System.Threading.Tasks.Task<CommandOrEvent> ReadCommandOrEventAsync(System.Threading.CancellationToken cancellationToken)
  public static class KernelCommandAndEventSenderExtensions
    public static System.Void NotifyIsReady()
    public static System.Threading.Tasks.Task NotifyIsReadyAsync(System.Threading.CancellationToken cancellationToken)
  public class KernelCommandAndEventTextReceiver : InteractiveProtocolKernelCommandAndEventReceiverBase, IKernelCommandAndEventReceiver
    .ctor(System.IO.TextReader reader)
    protected System.Threading.Tasks.Task<System.String> ReadMessageAsync(System.Threading.CancellationToken cancellationToken)
  public class KernelCommandAndEventTextStreamSender, IKernelCommandAndEventSender
    public static System.String Delimiter { get;}
    .ctor(System.IO.TextWriter writer)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand, System.Threading.CancellationToken cancellationToken)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Threading.CancellationToken cancellationToken)
  public class MultiplexingKernelCommandAndEventReceiver, IKernelCommandAndEventReceiver, System.IDisposable
    .ctor(IKernelCommandAndEventReceiver source)
    public System.Collections.Generic.IAsyncEnumerable<CommandOrEvent> CommandsAndEventsAsync(System.Threading.CancellationToken cancellationToken)
    public IKernelCommandAndEventReceiver CreateChildReceiver()
    public System.Void Dispose()
  public class NamedPipeKernelConnector, IKernelConnector
    .ctor(System.String pipeName)
    public System.String PipeName { get;}
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo)
  public class ProxyKernel : Microsoft.DotNet.Interactive.Kernel, System.IDisposable
    .ctor(System.String name, IKernelCommandAndEventReceiver receiver, IKernelCommandAndEventSender sender)
     System.Void DelegatePublication(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent)
    public Microsoft.DotNet.Interactive.ValueSharing.IKernelValueDeclarer GetValueDeclarer(System.Object value)
    public System.Threading.Tasks.Task StartAsync()
  public class StdIoKernelConnector, IKernelConnector
    .ctor(System.String[] command, System.IO.DirectoryInfo workingDirectory = null)
    public System.String[] Command { get;}
    public System.IO.DirectoryInfo WorkingDirectory { get;}
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Kernel> ConnectKernelAsync(Microsoft.DotNet.Interactive.KernelInfo kernelInfo)
Microsoft.DotNet.Interactive.Events
  public class CodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode command)
    public System.String Code { get;}
    public System.String ToString()
  public class CommandCancelled : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.Cancel cancel)
    .ctor(Microsoft.DotNet.Interactive.Commands.Cancel cancel, Microsoft.DotNet.Interactive.Commands.KernelCommand cancelledCommand)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand CancelledCommand { get;}
  public class CommandFailed : KernelEvent
    .ctor(System.Exception exception, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.String message = null)
    .ctor(System.String message, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.Exception Exception { get;}
    public System.String Message { get; set;}
    public System.String ToString()
  public class CommandSucceeded : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.String ToString()
  public class CompleteCodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
    public System.String Code { get;}
    public System.String ToString()
  public class CompletionItem
    .ctor(System.String displayText, System.String kind, System.String filterText = null, System.String sortText = null, System.String insertText = null, System.String documentation = null)
    public System.String DisplayText { get;}
    public System.String Documentation { get; set;}
    public System.String FilterText { get;}
    public System.String InsertText { get;}
    public System.String Kind { get;}
    public System.String SortText { get;}
    public System.String ToString()
  public class CompletionsProduced : KernelEvent
    .ctor(System.Collections.Generic.IEnumerable<CompletionItem> completions, Microsoft.DotNet.Interactive.Commands.RequestCompletions command, Microsoft.DotNet.Interactive.LinePositionSpan linePositionSpan = null)
    public System.Collections.Generic.IEnumerable<CompletionItem> Completions { get;}
    public Microsoft.DotNet.Interactive.LinePositionSpan LinePositionSpan { get;}
  public abstract class DiagnosticEvent : KernelEvent
  public class DiagnosticLogEntryProduced : DiagnosticEvent
    .ctor(System.String message, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.String Message { get;}
    public System.String ToString()
  public class DiagnosticsProduced : KernelEvent
    .ctor(System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> diagnostics, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedDiagnostics = null)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.Diagnostic> Diagnostics { get;}
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> FormattedDiagnostics { get;}
    public System.String ToString()
  public class DisplayedValueProduced : DisplayEvent
    .ctor(System.Object value, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class DisplayedValueUpdated : DisplayEvent
    .ctor(System.Object value, System.String valueId, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null)
  public abstract class DisplayEvent : KernelEvent
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> FormattedValues { get;}
    public System.Object Value { get;}
    public System.String ValueId { get;}
    public System.String ToString()
  public class ErrorProduced : DisplayEvent
    .ctor(System.String message, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null)
    public System.String Message { get;}
  public class HoverTextProduced : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.RequestHoverText command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> content, Microsoft.DotNet.Interactive.LinePositionSpan linePositionSpan = null)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> Content { get;}
    public Microsoft.DotNet.Interactive.LinePositionSpan LinePositionSpan { get;}
  public class IncompleteCodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
  public abstract class KernelEvent
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public System.String ToString()
  public class KernelExtensionLoaded : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    .ctor(Microsoft.DotNet.Interactive.IKernelExtension kernelExtension, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.IKernelExtension KernelExtension { get;}
  public class KernelReady : KernelEvent
    .ctor()
  public class PackageAdded : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.ResolvedPackageReference packageReference, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.ResolvedPackageReference PackageReference { get;}
    public System.String ToString()
  public class ReturnValueProduced : DisplayEvent
    .ctor(System.Object value, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class SignatureHelpProduced : KernelEvent
    public static SignatureHelpProduced Empty(Microsoft.DotNet.Interactive.Commands.RequestSignatureHelp command)
    .ctor(Microsoft.DotNet.Interactive.Commands.RequestSignatureHelp command, System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.SignatureInformation> signatures, System.Int32 activeSignatureIndex, System.Int32 activeParameterIndex)
    public System.Int32 ActiveParameterIndex { get;}
    public System.Int32 ActiveSignatureIndex { get;}
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.SignatureInformation> Signatures { get;}
  public class StandardErrorValueProduced : DisplayEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class StandardOutputValueProduced : DisplayEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class ValueInfosProduced : KernelEvent
    .ctor(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo> valueInfos, Microsoft.DotNet.Interactive.Commands.RequestValueInfos command)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo> ValueInfos { get;}
  public class ValueProduced : KernelEvent
    .ctor(System.Object value, System.String name, Microsoft.DotNet.Interactive.FormattedValue formattedValue, Microsoft.DotNet.Interactive.Commands.RequestValue command)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String Name { get;}
    public System.Object Value { get;}
  public class WorkingDirectoryChanged : KernelEvent
    .ctor(System.String workingDirectory, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.String WorkingDirectory { get;}
Microsoft.DotNet.Interactive.Extensions
  public class AssemblyBasedExtensionLoader, Microsoft.DotNet.Interactive.IKernelExtensionLoader
    .ctor()
    public System.Threading.Tasks.Task LoadFromAssembliesInDirectory(System.IO.DirectoryInfo directory, Microsoft.DotNet.Interactive.Kernel kernel, Microsoft.DotNet.Interactive.KernelInvocationContext context)
    public System.Threading.Tasks.Task LoadFromDirectoryAsync(System.IO.DirectoryInfo directory, Microsoft.DotNet.Interactive.Kernel kernel, Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public abstract class IExtensibleKernel
    public System.Threading.Tasks.Task LoadExtensionsFromDirectoryAsync(System.IO.DirectoryInfo directory, Microsoft.DotNet.Interactive.KernelInvocationContext invocationContext)
  public class ScriptBasedExtensionLoader, Microsoft.DotNet.Interactive.IKernelExtensionLoader
    .ctor()
    public System.Threading.Tasks.Task LoadFromDirectoryAsync(System.IO.DirectoryInfo directory, Microsoft.DotNet.Interactive.Kernel kernel, Microsoft.DotNet.Interactive.KernelInvocationContext context)
Microsoft.DotNet.Interactive.Http
  public static class JavascriptUtilities
    public static System.String GetCodeForEnsureRequireJs(System.Uri requireJsUri = null, System.String onRequirejsLoadedCallBackName = null)
Microsoft.DotNet.Interactive.Parsing
  public class ActionDirectiveNode : DirectiveNode
    public System.String ParentKernelName { get;}
  public class Diagnostic
    public Location Location { get;}
    public System.String Message { get;}
    public DiagnosticSeverity Severity { get;}
  public enum DiagnosticSeverity : System.Enum, System.IComparable, System.IConvertible, System.IFormattable
    Hidden=0
    Info=1
    Warning=2
    Error=3
  public class DirectiveArgsToken : SyntaxToken
  public class DirectiveHelpBuilder : System.CommandLine.Help.HelpBuilder, System.CommandLine.Help.IHelpBuilder
    .ctor(System.String rootCommandName)
    public System.String GetHelpForSymbol(System.CommandLine.ISymbol symbol)
    public System.Void Write(System.CommandLine.ICommand command)
  public abstract class DirectiveNode : LanguageNode
    public System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics()
    public System.CommandLine.Parsing.ParseResult GetDirectiveParseResult()
  public class DirectiveToken : SyntaxToken
    public System.String DirectiveName { get;}
  public class KernelNameDirectiveNode : DirectiveNode
  public class LanguageNode : SyntaxNode
    public System.String KernelName { get;}
    public System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics()
  public class LanguageSpecificParseResult
    public static LanguageSpecificParseResult None { get;}
    .ctor()
    public System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics()
  public class LanguageToken : SyntaxToken
  public class Location
    public Microsoft.CodeAnalysis.Text.TextSpan SourceSpan { get;}
    public PolyglotSyntaxTree SourceTree { get;}
  public class PolyglotSubmissionNode : SyntaxNode
    public System.String DefaultLanguage { get;}
  public class PolyglotSyntaxTree
    public System.Int32 Length { get;}
    public System.Int32 GetAbsolutePosition(Microsoft.DotNet.Interactive.LinePosition linePosition)
    public System.String GetLanguageAtPosition(System.Int32 position)
    public SyntaxNode GetRoot()
    public System.String ToString()
  public class SubmissionParser
    public static Microsoft.DotNet.Interactive.Events.CompletionItem CompletionItemFor(System.String name, System.CommandLine.Parsing.ParseResult parseResult)
    .ctor(Microsoft.DotNet.Interactive.Kernel kernel)
    public System.Collections.Generic.IReadOnlyList<System.CommandLine.ICommand> Directives { get;}
    public System.String KernelLanguage { get;}
    public System.Void AddDirective(System.CommandLine.Command command)
    public PolyglotSyntaxTree Parse(System.String code, System.String language = null)
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Commands.KernelCommand> SplitSubmission(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Commands.KernelCommand> SplitSubmission(Microsoft.DotNet.Interactive.Commands.RequestDiagnostics requestDiagnostics)
  public abstract class SyntaxNode : SyntaxNodeOrToken
    public System.Collections.Generic.IEnumerable<SyntaxNode> ChildNodes { get;}
    public System.Collections.Generic.IReadOnlyList<SyntaxNodeOrToken> ChildNodesAndTokens { get;}
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> ChildTokens { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public System.Boolean Contains(SyntaxNode node)
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens()
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf()
    public SyntaxNode FindNode(Microsoft.CodeAnalysis.Text.TextSpan span)
    public SyntaxNode FindNode(System.Int32 position)
    public SyntaxToken FindToken(System.Int32 position)
    public System.Collections.Generic.IEnumerable<Diagnostic> GetDiagnostics()
  public abstract class SyntaxNodeOrToken
    public SyntaxNode Parent { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public PolyglotSyntaxTree SyntaxTree { get;}
    public System.String Text { get;}
    protected Microsoft.CodeAnalysis.Text.SourceText get_SourceText()
    public System.String ToString()
  public abstract class SyntaxToken : SyntaxNodeOrToken
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public System.String ToString()
  public class TriviaToken : SyntaxToken
Microsoft.DotNet.Interactive.Server
  public class FileSystemInfoJsonConverter : Microsoft.DotNet.Interactive.JsonConverter<System.IO.FileSystemInfo>
    .ctor()
    public System.IO.FileSystemInfo Read(ref System.Text.Json.Utf8JsonReader& reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
    public System.Void Write(System.Text.Json.Utf8JsonWriter writer, System.IO.FileSystemInfo value, System.Text.Json.JsonSerializerOptions options)
  public abstract class IInputTextStream, System.IDisposable, System.IObservable<System.String>
    public System.Boolean IsStarted { get;}
  public abstract class IKernelCommandEnvelope
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public System.String CommandId { get;}
    public System.String CommandType { get;}
    public System.Uri DestinationUri { get;}
    public System.Uri OriginUri { get;}
    public System.String Token { get;}
  public abstract class IKernelEventEnvelope
    public Microsoft.DotNet.Interactive.Events.KernelEvent Event { get;}
    public System.String EventType { get;}
  public abstract class KernelCommandEnvelope, IKernelCommandEnvelope
    public static IKernelCommandEnvelope Create(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static IKernelCommandEnvelope Deserialize(System.String json)
    public static IKernelCommandEnvelope Deserialize(System.Text.Json.JsonElement json)
    public static System.Void ResetToDefaults()
    public static System.String Serialize(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static System.String Serialize(IKernelCommandEnvelope envelope)
    public System.String CommandId { get;}
    public System.String CommandType { get;}
    public System.Uri DestinationUri { get;}
    public System.Uri OriginUri { get;}
    public System.String Token { get;}
  public class KernelCommandEnvelope<T> : KernelCommandEnvelope, IKernelCommandEnvelope
    .ctor(T command)
    public T Command { get;}
    public System.String CommandType { get;}
  public abstract class KernelEventEnvelope, IKernelEventEnvelope
    public static IKernelEventEnvelope Create(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public static IKernelEventEnvelope Deserialize(System.String json)
    public static IKernelEventEnvelope Deserialize(System.Text.Json.JsonElement jsonObject)
    public static IKernelEventEnvelope DeserializeWithCommand(System.String json, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static IKernelEventEnvelope DeserializeWithCommand(System.Text.Json.JsonElement jsonObject, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static System.Void RegisterEvent<TEvent>()
    public static System.Void ResetToDefaults()
    public static System.String Serialize(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public static System.String Serialize(IKernelEventEnvelope eventEnvelope)
    public System.String CommandType { get;}
    public System.String EventType { get;}
  public class KernelEventEnvelope<T> : KernelEventEnvelope, IKernelEventEnvelope
    .ctor(T event)
    public T Event { get;}
    public System.String EventType { get;}
Microsoft.DotNet.Interactive.Utility
  public class AddPackageResult : CommandLineResult
    .ctor(System.Int32 exitCode, System.Collections.Generic.IReadOnlyCollection<System.String> output = null, System.Collections.Generic.IReadOnlyCollection<System.String> error = null)
    public System.Collections.Generic.IEnumerable<System.String> DetailedErrors { get;}
    public System.String InstalledVersion { get;}
  public static class AsyncContext
    public static System.Nullable<System.Int32> Id { get;}
    public static System.Boolean TryEstablish(ref System.Int32& id)
  public static class CommandLine
    public static System.String AppendArgs(System.String append = null)
    public static System.Threading.Tasks.Task<System.Int32> Complete()
    public static System.Threading.Tasks.Task<CommandLineResult> Execute(System.IO.FileInfo exePath, System.String args, System.IO.DirectoryInfo workingDir = null, System.Nullable<System.TimeSpan> timeout = null)
    public static System.Threading.Tasks.Task<CommandLineResult> Execute(System.String command, System.String args, System.IO.DirectoryInfo workingDir = null, System.Nullable<System.TimeSpan> timeout = null)
    public static System.Diagnostics.Process StartProcess(System.String command, System.String args, System.IO.DirectoryInfo workingDir, System.Action<System.String> output = null, System.Action<System.String> error = null, System.ValueTuple<System.String,System.String> environmentVariables)
    public static Task<T> Timeout<T>(System.TimeSpan timeout)
  public class CommandLineInvocationException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(CommandLineResult result, System.String message = null)
  public class CommandLineResult
    .ctor(System.Int32 exitCode, System.Collections.Generic.IReadOnlyCollection<System.String> output = null, System.Collections.Generic.IReadOnlyCollection<System.String> error = null)
    public System.Collections.Generic.IReadOnlyCollection<System.String> Error { get;}
    public System.Int32 ExitCode { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.String> Output { get;}
    public System.Void ThrowOnFailure(System.String message = null)
  public static class DirectoryUtility
    public static System.IO.DirectoryInfo EnsureExists()
  public class DisposableDirectory, System.IDisposable
    public static DisposableDirectory Create()
    .ctor(System.IO.DirectoryInfo directory)
    public System.IO.DirectoryInfo Directory { get;}
    public System.Void Dispose()
  public class Dotnet
    public static System.IO.FileInfo Path { get;}
    public static System.String GetDataFromAppDomain(System.String propertyName)
    .ctor(System.IO.DirectoryInfo workingDirectory = null)
    public System.Threading.Tasks.Task<AddPackageResult> AddPackage(System.String packageId, System.String version = null)
    public System.Threading.Tasks.Task<CommandLineResult> AddReference(System.IO.FileInfo projectToReference, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Build(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Clean(System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Execute(System.String args, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> New(System.String templateName, System.String args = null)
    public System.Threading.Tasks.Task<CommandLineResult> Pack(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Publish(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Diagnostics.Process StartProcess(System.String args, System.Action<System.String> output = null, System.Action<System.String> error = null)
    public System.Threading.Tasks.Task<CommandLineResult> ToolInstall(System.String packageName, System.IO.DirectoryInfo toolPath, System.String addSource = null, System.String version = null)
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.String>> ToolList(System.IO.DirectoryInfo directory)
    public System.Threading.Tasks.Task<CommandLineResult> VSTest(System.String args)
  public static class FileNameUtilities
    public static System.String ExecutableName()
  public class GCPressure, System.IDisposable
    .ctor(System.Int64 bytesAllocated)
    public System.Void Dispose()
  public class MultiplexingTextWriter : System.IO.TextWriter, System.IAsyncDisposable, System.IDisposable
    .ctor(System.String name, System.Func<System.IO.TextWriter> createTextWriter = null, System.IO.TextWriter defaultWriter = null)
    public System.Text.Encoding Encoding { get;}
    public System.Collections.Generic.IEnumerable<System.IO.TextWriter> Writers { get;}
    protected System.Void Dispose(System.Boolean disposing)
    public System.IDisposable EnsureInitializedForCurrentAsyncContext()
    public System.IObservable<System.String> GetObservable()
    public System.String ToString()
    public System.Void Write(System.Char value)
    public System.Void Write(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void Write(System.String value)
    public System.Void Write(System.Boolean value)
    public System.Void Write(System.Char[] buffer)
    public System.Void Write(System.Decimal value)
    public System.Void Write(System.Double value)
    public System.Void Write(System.Int32 value)
    public System.Void Write(System.Int64 value)
    public System.Void Write(System.Object value)
    public System.Void Write(System.ReadOnlySpan<System.Char> buffer)
    public System.Void Write(System.Single value)
    public System.Void Write(System.String format, System.Object arg0)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void Write(System.String format, System.Object[] arg)
    public System.Void Write(System.UInt32 value)
    public System.Void Write(System.UInt64 value)
    public System.Threading.Tasks.Task WriteAsync(System.Char value)
    public System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = null)
    public System.Threading.Tasks.Task WriteAsync(System.String value)
    public System.Void WriteLine()
    public System.Void WriteLine(System.Char value)
    public System.Void WriteLine(System.Boolean value)
    public System.Void WriteLine(System.Char[] buffer)
    public System.Void WriteLine(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void WriteLine(System.Decimal value)
    public System.Void WriteLine(System.Double value)
    public System.Void WriteLine(System.Int32 value)
    public System.Void WriteLine(System.Int64 value)
    public System.Void WriteLine(System.Object value)
    public System.Void WriteLine(System.ReadOnlySpan<System.Char> buffer)
    public System.Void WriteLine(System.Single value)
    public System.Void WriteLine(System.String value)
    public System.Void WriteLine(System.String format, System.Object arg0)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void WriteLine(System.String format, System.Object[] arg)
    public System.Void WriteLine(System.UInt32 value)
    public System.Void WriteLine(System.UInt64 value)
    public System.Threading.Tasks.Task WriteLineAsync()
    public System.Threading.Tasks.Task WriteLineAsync(System.Char value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = null)
    public System.Threading.Tasks.Task WriteLineAsync(System.String value)
  public class ObservableStringWriter : System.IO.StringWriter, System.IAsyncDisposable, System.IDisposable, System.IObservable<System.String>
    .ctor()
    protected System.Void Dispose(System.Boolean disposing)
    public System.IDisposable Subscribe(System.IObserver<System.String> observer)
    public System.Void Write(System.Char value)
    public System.Void Write(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void Write(System.String value)
    public System.Void Write(System.Boolean value)
    public System.Void Write(System.Char[] buffer)
    public System.Void Write(System.Decimal value)
    public System.Void Write(System.Double value)
    public System.Void Write(System.Int32 value)
    public System.Void Write(System.Int64 value)
    public System.Void Write(System.Object value)
    public System.Void Write(System.Single value)
    public System.Void Write(System.String format, System.Object arg0)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void Write(System.String format, System.Object[] arg)
    public System.Void Write(System.UInt32 value)
    public System.Void Write(System.UInt64 value)
    public System.Threading.Tasks.Task WriteAsync(System.Char value)
    public System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteAsync(System.String value)
    public System.Void WriteLine()
    public System.Void WriteLine(System.Boolean value)
    public System.Void WriteLine(System.Char value)
    public System.Void WriteLine(System.Char[] buffer)
    public System.Void WriteLine(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void WriteLine(System.Decimal value)
    public System.Void WriteLine(System.Double value)
    public System.Void WriteLine(System.Int32 value)
    public System.Void WriteLine(System.Int64 value)
    public System.Void WriteLine(System.Object value)
    public System.Void WriteLine(System.Single value)
    public System.Void WriteLine(System.String value)
    public System.Void WriteLine(System.String format, System.Object arg0)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void WriteLine(System.String format, System.Object[] arg)
    public System.Void WriteLine(System.UInt32 value)
    public System.Void WriteLine(System.UInt64 value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteLineAsync(System.String value)
    public System.Threading.Tasks.Task WriteLineAsync()
    public System.Collections.Generic.IEnumerable<System.String> Writes()
  public enum PathKind : System.Enum, System.IComparable, System.IConvertible, System.IFormattable
    Empty=0
    Relative=1
    RelativeToCurrentDirectory=2
    RelativeToCurrentParent=3
    RelativeToCurrentRoot=4
    RelativeToDriveDirectory=5
    Absolute=6
  public static class Paths
    public static System.String DotnetHomePath { get;}
    public static System.String DotnetToolsPath { get;}
    public static System.String DotnetUserProfileFolderPath { get;}
    public static System.String NugetCache { get;}
    public static System.String UserProfile { get;}
  public static class PathUtilities
    public static System.String ChangeExtension(System.String path, System.String extension)
    public static System.String CombineAbsoluteAndRelativePaths(System.String root, System.String relativePath)
    public static System.String CombinePathsUnchecked(System.String root, System.String relativePath)
    public static System.String CombinePossiblyRelativeAndRelativePaths(System.String rootOpt, System.String relativePath)
    public static System.Boolean ContainsPathComponent(System.String path, System.String component, System.Boolean ignoreCase)
    public static System.String EnsureTrailingSeparator()
    public static System.String GetDirectoryName(System.String path)
    public static System.String GetExtension(System.String path)
    public static System.String GetFileName(System.String path, System.Boolean includeExtension = True)
    public static PathKind GetPathKind(System.String path)
    public static System.String GetPathRoot(System.String path)
    public static System.String GetRelativePath(System.String directory, System.String fullPath)
    public static System.Boolean IsAbsolute(System.String path)
    public static System.Boolean IsAnyDirectorySeparator(System.Char c)
    public static System.Boolean IsChildPath(System.String parentPath, System.String childPath)
    public static System.Boolean IsDirectorySeparator(System.Char c)
    public static System.Boolean IsFilePath(System.String assemblyDisplayNameOrPath)
    public static System.Boolean IsValidFilePath(System.String fullPath)
    public static System.String NormalizePathPrefix(System.String filePath, System.Collections.Immutable.ImmutableArray<System.Collections.Generic.KeyValuePair<System.String,System.String>> pathMap)
    public static System.Boolean PathsEqual(System.String path1, System.String path2)
    public static System.String RemoveExtension(System.String path)
    public static System.String TrimTrailingSeparators()
  public static class SourceUtilities
    public static System.Int32 ComputeReplacementStartPosition(System.String code, System.Int32 cursorPosition)
    public static System.Int32 GetCursorOffsetFromPosition(System.String code, Microsoft.DotNet.Interactive.LinePosition position)
    public static Microsoft.DotNet.Interactive.LinePositionSpan GetLinePositionSpanFromStartAndEndIndices(System.String code, System.Int32 startIndex, System.Int32 endIndex)
    public static Microsoft.DotNet.Interactive.LinePosition GetPositionFromCursorOffset(System.String code, System.Int32 cursorOffset)
Microsoft.DotNet.Interactive.ValueSharing
  public abstract class IKernelValueDeclarer
    public System.Boolean TryGetValueDeclaration(System.String valueName, System.Object value, ref Microsoft.DotNet.Interactive.Commands.KernelCommand& command)
  public abstract class ISupportGetValue
    public System.Collections.Generic.IReadOnlyCollection<KernelValueInfo> GetValueInfos()
    public System.Boolean TryGetValue<T>(System.String name, ref T& value)
  public abstract class ISupportSetClrValue
    public System.Threading.Tasks.Task SetValueAsync(System.String name, System.Object value, System.Type declaredType = null)
  public class JavaScriptKernelValueDeclarer, IKernelValueDeclarer
    .ctor()
    public System.Boolean TryGetValueDeclaration(System.String valueName, System.Object value, ref Microsoft.DotNet.Interactive.Commands.KernelCommand& command)
  public class KernelValue
    .ctor(KernelValueInfo valueInfo, System.Object value, System.String kernelName)
    public System.String KernelName { get;}
    public System.String Name { get;}
    public System.Type Type { get;}
    public System.Object Value { get;}
  public static class KernelValueDeclarer
    public static IKernelValueDeclarer Default { get;}
  public class KernelValueInfo
    .ctor(System.String name, System.Type type = null)
    public System.String Name { get;}
    public System.Type Type { get;}
  public class KernelValues, System.Collections.Generic.IEnumerable<KernelValue>, System.Collections.IEnumerable
    .ctor(System.Collections.Generic.IEnumerable<KernelValue> variables, System.Boolean detailed)
    public System.Boolean Detailed { get;}
    public System.Collections.Generic.IEnumerator<KernelValue> GetEnumerator()
System
  public static class DisplayExtensions
    public static Microsoft.DotNet.Interactive.DisplayedValue Display(String[] mimeTypes)
    public static Microsoft.DotNet.Interactive.DisplayedValue DisplayAs(String mimeType, String[] additionalMimeTypes)
