Microsoft.DotNet.Interactive
  public class AutomationEnvironment : FrontendEnvironment
    .ctor()
  public class Base64EncodedAssembly
    .ctor(System.String value)
    public System.String Value { get;}
  public class ChooseKernelDirective : System.CommandLine.Command, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.Completions.ICompletionSource
    .ctor(Kernel kernel, System.String description = null)
    public Kernel Kernel { get;}
    protected System.Threading.Tasks.Task Handle(KernelInvocationContext kernelInvocationContext, System.CommandLine.Invocation.InvocationContext commandLineInvocationContext)
  public class ChooseKeyValueStoreKernelDirective : ChooseKernelDirective, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.Completions.ICompletionSource
    .ctor(Kernel kernel)
    public System.CommandLine.Option<System.IO.FileInfo> FromFileOption { get;}
    public System.CommandLine.Option<System.Uri> FromUrlOption { get;}
    public System.CommandLine.Option<System.String> FromValueOption { get;}
    public System.CommandLine.Option<System.String> MimeTypeOption { get;}
    public System.CommandLine.Option<System.String> NameOption { get;}
    protected System.Threading.Tasks.Task Handle(KernelInvocationContext kernelInvocationContext, System.CommandLine.Invocation.InvocationContext commandLineInvocationContext)
  public class CodeSubmissionCompilationErrorException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.Exception innerException)
  public class CommandNotSupportedException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.Type commandType, Kernel kernel)
  public class CommandRoutingSlip : RoutingSlip
    .ctor()
    public System.Void Stamp(System.Uri uri)
    public System.Void StampAs(System.Uri uri, System.String tag)
    public System.Void StampAsArrived(System.Uri uri)
  public class CompositeKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, System.Collections.Generic.IEnumerable<Kernel>, System.Collections.IEnumerable, System.IDisposable
    .ctor(System.String name = null)
    public KernelCollection ChildKernels { get;}
    public System.String DefaultKernelName { get; set;}
    public KernelHost Host { get;}
    public System.Void Add(Kernel kernel, System.Collections.Generic.IEnumerable<System.String> aliases = null)
    public System.Void AddKernelConnector(Microsoft.DotNet.Interactive.Connection.ConnectKernelCommand connectionCommand)
     System.Collections.Generic.IEnumerable<System.CommandLine.Parsing.Parser> GetDirectiveParsersForCompletion(Microsoft.DotNet.Interactive.Parsing.DirectiveNode directiveNode, System.Int32 requestPosition)
    public System.Collections.Generic.IEnumerator<Kernel> GetEnumerator()
     Kernel GetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
     System.Threading.Tasks.Task HandleRequestKernelInfoAsync(Microsoft.DotNet.Interactive.Commands.RequestKernelInfo command, KernelInvocationContext context)
    public System.Void SetDefaultTargetKernelNameForCommand(System.Type commandType, System.String kernelName)
    protected System.Void SetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public class DataDictionaryConverter : JsonConverter<System.Collections.Generic.IDictionary<System.String,System.Object>>
    .ctor()
    public System.Collections.Generic.IDictionary<System.String,System.Object> Read(ref System.Text.Json.Utf8JsonReader& reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
  public static class DataExplorer
    public static DataExplorer<TData> Create<TData>(System.String dataExplorerTypeName, TData data)
    public static DataExplorer<TData> CreateDefault<TData>(TData data)
    public static System.Void Register(System.Type dataType, System.Type dataExplorerType)
    public static System.Void Register<TData, TExplorer>()
    public static System.Void ResetToDefault()
    public static System.Void SetDefault<TData, TExplorer>()
  public abstract class DataExplorer<TData>
    public static System.Void Register<TDataExplorer>()
    public static System.Void RegisterFormatters()
    public TData Data { get;}
    public System.String Id { get;}
    protected Microsoft.AspNetCore.Html.IHtmlContent ToHtml()
  public class Diagnostic
    public static Diagnostic FromCodeAnalysisDiagnostic(Microsoft.CodeAnalysis.Diagnostic diagnostic)
    .ctor(LinePositionSpan linePositionSpan, Microsoft.CodeAnalysis.DiagnosticSeverity severity, System.String code, System.String message)
    public System.String Code { get;}
    public LinePositionSpan LinePositionSpan { get;}
    public System.String Message { get;}
    public Microsoft.CodeAnalysis.DiagnosticSeverity Severity { get;}
    public System.String ToString()
    public Diagnostic WithLinePositionSpan(LinePositionSpan linePositionSpan)
  public class DisplayedValue
    .ctor(System.Collections.Generic.IReadOnlyList<FormattedValue> formattedValues, KernelInvocationContext context)
    public System.String DisplayId { get;}
    public System.Collections.Generic.IReadOnlyList<FormattedValue> FormattedValues { get;}
    public System.Void Update(System.Object updatedValue)
  public class EventRoutingSlip : RoutingSlip
    .ctor()
    public System.Void Stamp(System.Uri uri)
  public class FormattedValue
    public static System.Collections.Generic.IReadOnlyList<FormattedValue> CreateManyFromObject(System.Object value, System.String[] mimeTypes)
    public static FormattedValue CreateSingleFromObject(System.Object value, System.String mimeType = null)
    .ctor(System.String mimeType, System.String value)
    public System.String MimeType { get;}
    public System.Boolean SuppressDisplay { get; set;}
    public System.String Value { get;}
  public abstract class FrontendEnvironment
    public System.Threading.Tasks.Task ExecuteClientScript(System.String code, KernelInvocationContext context)
  public class HtmlKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
  public abstract class IKernelCommandHandler<TCommand>
    public System.Threading.Tasks.Task HandleAsync(TCommand command, KernelInvocationContext context)
  public abstract class IKernelExtension
    public System.Threading.Tasks.Task OnLoadAsync(Kernel kernel)
  public abstract class IKernelScheduler<T,TResult>
    public Task<TResult> RunAsync(T value, KernelSchedulerDelegate<T,TResult> onExecuteAsync, System.String scope = default, System.Threading.CancellationToken cancellationToken = null)
  public class InstallPackagesMessage
    .ctor(System.Collections.Generic.IReadOnlyList<System.String> restoreSources, System.Collections.Generic.IReadOnlyList<System.String> installingPackages, System.Collections.Generic.IReadOnlyList<System.String> installedPackages, System.Int32 progress)
    public System.Collections.Generic.IReadOnlyList<System.String> InstalledPackages { get; set;}
    public System.Collections.Generic.IReadOnlyList<System.String> InstallingPackages { get; set;}
    public System.Int32 Progress { get; set;}
    public System.Collections.Generic.IReadOnlyList<System.String> RestoreSources { get; set;}
    public System.String FormatAsHtml()
    public System.String FormatAsPlainText()
    public System.Collections.Generic.IEnumerable<System.String> FormatAsPlainTextLines()
  public abstract class IStaticContentSource
    public System.String Name { get;}
  public class JavaScriptKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SendValue>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor(Microsoft.DotNet.Interactive.Connection.KernelClientBase client = null)
    protected Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> CreateDefaultHandlerForCommandType<TCommand>()
    public System.Threading.Tasks.Task HandleAsync(Microsoft.DotNet.Interactive.Commands.SendValue command, KernelInvocationContext context)
  public abstract class JsonConverter<T> : JsonConverter<T>
    protected System.Void EnsureStartObject(System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert)
    protected System.Void OnWrite(System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options)
    public System.Void Write(System.Text.Json.Utf8JsonWriter writer, T value, System.Text.Json.JsonSerializerOptions options)
  public abstract class Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, System.IDisposable
    public static Kernel Current { get;}
    public static Kernel Root { get;}
    public static System.Void CSS(System.String content)
    public static DisplayedValue display(System.Object value, System.String[] mimeTypes)
    public static System.Threading.Tasks.Task<System.String> GetInputAsync(System.String prompt = , System.String typeHint = text, System.String valueName = null)
    public static System.Threading.Tasks.Task<System.String> GetPasswordAsync(System.String prompt = , System.String valueName = null)
    public static Microsoft.AspNetCore.Html.IHtmlContent HTML(System.String content)
    public static System.Void Javascript(System.String scriptContent)
    public ChooseKernelDirective ChooseKernelDirective { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.CommandLine.Command> Directives { get;}
    public FrontendEnvironment FrontendEnvironment { get; set;}
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public KernelInfo KernelInfo { get;}
    public System.String Name { get;}
    public CompositeKernel ParentKernel { get;}
    public Kernel RootKernel { get;}
    public System.Int32 SubmissionCount { get;}
    public Microsoft.DotNet.Interactive.Parsing.SubmissionParser SubmissionParser { get;}
    public System.Void AddDirective(System.CommandLine.Command command)
    public System.Void AddMiddleware(KernelCommandPipelineMiddleware middleware, System.String caller = null)
     System.Boolean CanHandle(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    protected Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> CreateDefaultHandlerForCommandType<TCommand>()
    public System.Void DeferCommand(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.Void Dispose()
    protected System.Boolean get_IsDisposed()
     KernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult> get_Scheduler()
     System.Collections.Generic.IEnumerable<System.CommandLine.Parsing.Parser> GetDirectiveParsersForCompletion(Microsoft.DotNet.Interactive.Parsing.DirectiveNode directiveNode, System.Int32 requestPosition)
     Kernel GetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
     System.Threading.Tasks.Task HandleRequestKernelInfoAsync(Microsoft.DotNet.Interactive.Commands.RequestKernelInfo command, KernelInvocationContext context)
     System.Boolean HasDynamicHandlerFor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
     System.Void PublishEvent(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent)
    public System.Void RegisterCommandHandler<TCommand>(Func<TCommand,KernelInvocationContext,System.Threading.Tasks.Task> handler)
    public System.Void RegisterCommandType<TCommand>()
    public System.Void RegisterForDisposal(System.Action dispose)
    public System.Void RegisterForDisposal(System.IDisposable disposable)
    public System.Threading.Tasks.Task<KernelCommandResult> SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Threading.CancellationToken cancellationToken = null)
    protected System.Void SetHandlingKernel(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
     System.Void SetScheduler(KernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult> scheduler)
    protected System.Threading.Tasks.Task SetValueAsync(Microsoft.DotNet.Interactive.Commands.SendValue command, KernelInvocationContext context, SetValueAsyncDelegate setValueAsync)
    public System.Boolean SupportsCommandType(System.Type commandType)
    public System.String ToString()
  public class KernelCollection, System.Collections.Generic.IEnumerable<Kernel>, System.Collections.Generic.IReadOnlyCollection<Kernel>, System.Collections.IEnumerable
    .ctor(CompositeKernel compositeKernel)
    public System.Int32 Count { get;}
    public System.Collections.Generic.IEnumerator<Kernel> GetEnumerator()
    public System.Boolean TryGetByAlias(System.String alias, ref Kernel& kernel)
    public System.Boolean TryGetByUri(System.Uri uri, ref Kernel& kernel)
  public class KernelCommandInfo, System.IEquatable<KernelCommandInfo>
    public static System.Boolean op_Equality(KernelCommandInfo left, KernelCommandInfo right)
    public static System.Boolean op_Inequality(KernelCommandInfo left, KernelCommandInfo right)
    .ctor(System.String Name)
    public System.String Name { get; set;}
    public KernelCommandInfo <Clone>$()
    public System.Void Deconstruct(ref System.String& Name)
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(KernelCommandInfo other)
    protected System.Type get_EqualityContract()
    public System.Int32 GetHashCode()
    protected System.Boolean PrintMembers(System.Text.StringBuilder builder)
    public System.String ToString()
  public delegate KernelCommandInvocation : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public delegate KernelCommandPipelineMiddleware : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next)
  public class KernelCommandResult
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Events.KernelEvent> Events { get;}
  public class KernelCommandScheduler : KernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult>, IKernelScheduler<Microsoft.DotNet.Interactive.Commands.KernelCommand,KernelCommandResult>, System.IDisposable
    .ctor()
    protected System.Boolean IsChildOperation(Microsoft.DotNet.Interactive.Commands.KernelCommand current, Microsoft.DotNet.Interactive.Commands.KernelCommand incoming)
  public class KernelDirectiveInfo, System.IEquatable<KernelDirectiveInfo>
    public static System.Boolean op_Equality(KernelDirectiveInfo left, KernelDirectiveInfo right)
    public static System.Boolean op_Inequality(KernelDirectiveInfo left, KernelDirectiveInfo right)
    .ctor(System.String Name)
    public System.String Name { get; set;}
    public KernelDirectiveInfo <Clone>$()
    public System.Void Deconstruct(ref System.String& Name)
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(KernelDirectiveInfo other)
    protected System.Type get_EqualityContract()
    public System.Int32 GetHashCode()
    protected System.Boolean PrintMembers(System.Text.StringBuilder builder)
    public System.String ToString()
  public class KernelException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.String message)
  public class KernelExtensionLoadException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(System.Exception innerException)
  public static class KernelExtensions
    public static Kernel FindKernelByName(System.String name)
    public static System.Collections.Generic.IEnumerable<Kernel> FindKernels(System.Func<Kernel,System.Boolean> predicate)
    public static System.Threading.Tasks.Task LoadAndRunInteractiveDocument(System.IO.FileInfo file)
    public static System.Collections.Generic.IEnumerable<Kernel> Subkernels(System.Boolean recursive = False)
    public static System.Collections.Generic.IEnumerable<Kernel> SubkernelsAndSelf(System.Boolean recursive = False)
    public static System.Threading.Tasks.Task<KernelCommandResult> SubmitCodeAsync(System.String code)
    public static TKernel UseImportMagicCommand<TKernel>()
    public static T UseQuitCommand<T>(System.Func<System.Threading.Tasks.Task> onQuitAsync = null)
    public static T UseValueSharing<T>()
    public static TKernel UseWho<TKernel>()
    public static System.Void VisitSubkernels(System.Action<Kernel> onVisit, System.Boolean recursive = False)
    public static System.Void VisitSubkernelsAndSelf(System.Action<Kernel> onVisit, System.Boolean recursive = False)
  public class KernelHost, System.IDisposable
    public static System.Uri CreateHostUri(System.String name)
    public static System.Uri CreateHostUriForCurrentProcessId()
    public static System.Uri CreateHostUriForProcessId(System.Int32 processId)
    public System.Uri Uri { get;}
    public System.Threading.Tasks.Task ConnectAndWaitAsync()
    public System.Threading.Tasks.Task ConnectAsync()
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Connection.ProxyKernel> ConnectProxyKernelAsync(System.String localName, System.Func<System.String,System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Connection.ProxyKernel>> createKernelAsync, System.Uri remoteKernelUri, System.String[] aliases = null)
    public System.Threading.Tasks.Task<Microsoft.DotNet.Interactive.Connection.ProxyKernel> ConnectProxyKernelOnDefaultConnectorAsync(System.String localName, System.Uri remoteKernelUri, System.String[] aliases = null)
    public System.Void Dispose()
  public class KernelInfo
    .ctor(System.String localName, System.String[] aliases = null, System.Boolean isProxy = False, System.Boolean isComposite = False)
    public System.String[] Aliases { get; set;}
    public System.String DisplayName { get; set;}
    public System.Boolean IsComposite { get; set;}
    public System.Boolean IsProxy { get; set;}
    public System.String LanguageName { get; set;}
    public System.String LanguageVersion { get; set;}
    public System.String LocalName { get;}
    public System.Uri RemoteUri { get; set;}
    public System.Collections.Generic.ICollection<KernelDirectiveInfo> SupportedDirectives { get; set;}
    public System.Collections.Generic.ICollection<KernelCommandInfo> SupportedKernelCommands { get; set;}
    public System.Uri Uri { get; set;}
    public System.String ToString()
  public class KernelInvocationContext, System.IDisposable
    public static KernelInvocationContext Current { get;}
    public static KernelInvocationContext GetOrCreateAmbientContext(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Concurrent.ConcurrentDictionary<System.String,KernelInvocationContext> contextsByRootToken = null)
    public System.Threading.CancellationToken CancellationToken { get;}
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public Kernel HandlingKernel { get;}
    public System.Boolean IsComplete { get;}
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public KernelCommandResult Result { get;}
    public System.Void Complete(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.Void Dispose()
    public System.Void Fail(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Exception exception = null, System.String message = null)
    public System.Void OnComplete(System.Action<KernelInvocationContext> onComplete)
    public System.Void Publish(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public System.Void Publish(Microsoft.DotNet.Interactive.Events.KernelEvent event, System.Boolean publishOnAmbientContextOnly)
    public System.Threading.Tasks.Task ScheduleAsync(System.Func<KernelInvocationContext,System.Threading.Tasks.Task> func)
  public static class KernelInvocationContextExtensions
    public static DisplayedValue Display(System.Object value, System.String[] mimeTypes)
    public static DisplayedValue DisplayAs(System.String value, System.String mimeType)
    public static System.Void DisplayStandardError(System.String error, Microsoft.DotNet.Interactive.Commands.KernelCommand command = null)
    public static System.Void DisplayStandardOut(System.String output, Microsoft.DotNet.Interactive.Commands.KernelCommand command = null)
    public static System.Void PublishValueProduced(Microsoft.DotNet.Interactive.Commands.RequestValue requestValue, System.Object value)
  public delegate KernelPipelineContinuation : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context, System.AsyncCallback callback, System.Object object)
    public System.Threading.Tasks.Task EndInvoke(System.IAsyncResult result)
    public System.Threading.Tasks.Task Invoke(Microsoft.DotNet.Interactive.Commands.KernelCommand command, KernelInvocationContext context)
  public class KernelScheduler<T,TResult>, IKernelScheduler<T,TResult>, System.IDisposable
    .ctor()
    public System.Void CancelCurrentOperation()
    public System.Void Dispose()
    protected System.Boolean IsChildOperation(T current, T incoming)
    public System.Void RegisterDeferredOperationSource(GetDeferredOperationsDelegate getDeferredOperations, KernelSchedulerDelegate<T,TResult> kernelSchedulerOnExecuteAsync)
    public Task<TResult> RunAsync(T value, KernelSchedulerDelegate<T,TResult> onExecuteAsync, System.String scope = default, System.Threading.CancellationToken cancellationToken = null)
   delegate GetDeferredOperationsDelegate : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(T operationToExecute, System.String queueName, System.AsyncCallback callback, System.Object object)
    public IReadOnlyList<T> EndInvoke(System.IAsyncResult result)
    public IReadOnlyList<T> Invoke(T operationToExecute, System.String queueName)
  public delegate KernelSchedulerDelegate<T,TResult> : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(T value, System.AsyncCallback callback, System.Object object)
    public Task<TResult> EndInvoke(System.IAsyncResult result)
    public Task<TResult> Invoke(T value)
  public class KeyValueStoreKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestValue>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestValueInfos>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SendValue>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor(System.String name = value)
    public ChooseKernelDirective ChooseKernelDirective { get;}
    public System.Collections.Generic.IReadOnlyDictionary<System.String,FormattedValue> Values { get;}
    protected System.Threading.Tasks.Task StoreValueAsync(System.String key, System.String value, System.String mimeType, System.Boolean shouldDisplayValue, KernelInvocationContext context)
  public class KqlDiscoverabilityKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
  public class LinePosition, System.IEquatable<LinePosition>
    public static LinePosition FromCodeAnalysisLinePosition(Microsoft.CodeAnalysis.Text.LinePosition linePosition)
    public static System.Boolean op_Equality(LinePosition a, LinePosition b)
    public static System.Boolean op_Inequality(LinePosition a, LinePosition b)
    .ctor(System.Int32 line, System.Int32 character)
    public System.Int32 Character { get;}
    public System.Int32 Line { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(LinePosition other)
    public System.Int32 GetHashCode()
    public LinePosition SubtractLineOffset(LinePosition offset)
    public Microsoft.CodeAnalysis.Text.LinePosition ToCodeAnalysisLinePosition()
    public System.String ToString()
  public class LinePositionSpan, System.IEquatable<LinePositionSpan>
    public static LinePositionSpan FromCodeAnalysisLinePositionSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan linePositionSpan)
    public static System.Boolean op_Equality(LinePositionSpan a, LinePositionSpan b)
    public static System.Boolean op_Inequality(LinePositionSpan a, LinePositionSpan b)
    .ctor(LinePosition start, LinePosition end)
    public LinePosition End { get;}
    public LinePosition Start { get;}
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(LinePositionSpan other)
    public System.Int32 GetHashCode()
    public LinePositionSpan SubtractLineOffset(LinePosition offset)
    public System.String ToString()
  public class NoSuitableKernelException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
  public class PackageReference
    public static System.Boolean TryParse(System.String value, ref PackageReference& reference)
    .ctor(System.String packageName, System.String packageVersion = null)
    public System.Boolean IsPackageVersionSpecified { get;}
    public System.String PackageName { get;}
    public System.String PackageVersion { get;}
    public System.String ToString()
  public class PackageReferenceOrFileInfo
    public static PackageReferenceOrFileInfo op_Implicit(System.IO.FileInfo source)
    public static PackageReferenceOrFileInfo op_Implicit(PackageReference source)
    .ctor(System.IO.FileInfo fileInfo)
    .ctor(PackageReference packageReference)
    public System.IO.FileInfo FileInfo { get;}
    public PackageReference PackageReference { get;}
    public System.Object Value { get;}
  public class ParameterInformation
    .ctor(System.String label, FormattedValue documentation)
    public FormattedValue Documentation { get;}
    public System.String Label { get;}
  public class PasswordString
    .ctor(System.String clearTextPassword)
    public System.String GetClearTextPassword()
  public class ResolvedPackageReference : PackageReference
    .ctor(System.String packageName, System.String packageVersion, System.Collections.Generic.IReadOnlyList<System.String> assemblyPaths, System.String packageRoot = null, System.Collections.Generic.IReadOnlyList<System.String> probingPaths = null)
    public System.Collections.Generic.IReadOnlyList<System.String> AssemblyPaths { get;}
    public System.String PackageRoot { get;}
    public System.Collections.Generic.IReadOnlyList<System.String> ProbingPaths { get;}
    public System.String ToString()
  public abstract class RoutingSlip
    public System.Int32 Count { get;}
    public System.Boolean Contains(System.Uri uri, System.Boolean ignoreQuery = False)
    public System.Void ContinueWith(RoutingSlip other)
    public System.Void Stamp(System.Uri uri)
    public System.Boolean StartsWith(RoutingSlip other)
    public System.String ToString()
    public System.String[] ToUriArray()
  public class ScriptContent, Microsoft.AspNetCore.Html.IHtmlContent
    .ctor(System.String scriptValue)
    public System.String ScriptValue { get;}
    public System.Void WriteTo(System.IO.TextWriter writer, System.Text.Encodings.Web.HtmlEncoder encoder)
  public class SignatureInformation
    .ctor(System.String label, FormattedValue documentation, System.Collections.Generic.IReadOnlyList<ParameterInformation> parameters)
    public FormattedValue Documentation { get;}
    public System.String Label { get;}
    public System.Collections.Generic.IReadOnlyList<ParameterInformation> Parameters { get;}
  public class SqlDiscoverabilityKernel : Kernel, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>, System.IDisposable
    .ctor()
  public class TabularDataResourceSummaryExplorer : DataExplorer<Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResource>
    .ctor(Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResource data)
    protected Microsoft.AspNetCore.Html.IHtmlContent ToHtml()
Microsoft.DotNet.Interactive.Commands
  public class Cancel : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String targetKernelName = null)
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class ChangeWorkingDirectory : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String workingDirectory)
    public System.String WorkingDirectory { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class DisplayError : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String message)
    public System.String Message { get;}
  public class DisplayValue : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(Microsoft.DotNet.Interactive.FormattedValue formattedValue, System.String valueId = null)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String ValueId { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public abstract class KernelCommand, System.IEquatable<KernelCommand>
    public System.Uri DestinationUri { get; set;}
    public Microsoft.DotNet.Interactive.KernelCommandInvocation Handler { get; set;}
    public System.CommandLine.Parsing.ParseResult KernelChooserParseResult { get;}
    public System.Uri OriginUri { get; set;}
    public KernelCommand Parent { get;}
    public System.Collections.Generic.IDictionary<System.String,System.Object> Properties { get;}
    public Microsoft.DotNet.Interactive.CommandRoutingSlip RoutingSlip { get;}
    public System.String TargetKernelName { get;}
    public System.Boolean Equals(KernelCommand other)
    public System.String GetOrCreateToken()
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
    public System.Void SetParent(KernelCommand parent)
    public System.Void SetToken(System.String token)
  public abstract class LanguageServiceCommand : KernelCommand, System.IEquatable<KernelCommand>
    public System.String Code { get;}
    public Microsoft.DotNet.Interactive.LinePosition LinePosition { get;}
    protected System.Void set_Code(System.String value)
    protected System.Void set_LinePosition(Microsoft.DotNet.Interactive.LinePosition value)
  public class Quit : KernelCommand, System.IEquatable<KernelCommand>
    .ctor()
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
  public class RequestCompletions : LanguageServiceCommand, System.IEquatable<KernelCommand>
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestDiagnostics : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String code, System.String targetKernelName = null)
    public System.String Code { get;}
  public class RequestHoverText : LanguageServiceCommand, System.IEquatable<KernelCommand>
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestInput : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String prompt, System.String targetKernelName = null, System.String inputTypeHint = null, System.String valueName = null)
    public System.String InputTypeHint { get;}
    public System.Boolean IsPassword { get;}
    public System.String Prompt { get;}
    public System.String ValueName { get;}
  public class RequestKernelInfo : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String targetKernelName = null)
    .ctor(System.Uri destinationUri)
  public class RequestSignatureHelp : LanguageServiceCommand, System.IEquatable<KernelCommand>
    .ctor(System.String code, Microsoft.DotNet.Interactive.LinePosition linePosition, System.String targetKernelName = null)
  public class RequestValue : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String name, System.String mimeType = application/json, System.String targetKernelName = null)
    public System.String MimeType { get;}
    public System.String Name { get;}
  public class RequestValueInfos : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String targetKernelName = null, System.String mimeType = text/plain+summary)
    public System.String MimeType { get;}
  public class SendEditableCode : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String kernelName, System.String code, System.String targetKernelName = null)
    public System.String Code { get;}
    public System.String KernelName { get;}
  public class SendValue : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String name, System.Object value, Microsoft.DotNet.Interactive.FormattedValue formattedValue = null, System.String targetKernelName = null)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String Name { get;}
    public System.Object Value { get;}
  public class SubmitCode : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(System.String code, System.String targetKernelName = null)
    public System.String Code { get;}
    public System.String ToString()
  public class UpdateDisplayedValue : KernelCommand, System.IEquatable<KernelCommand>
    .ctor(Microsoft.DotNet.Interactive.FormattedValue formattedValue, System.String valueId)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String ValueId { get;}
    public System.Threading.Tasks.Task InvokeAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context)
Microsoft.DotNet.Interactive.Connection
  public class CommandOrEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand)
    .ctor(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Boolean isParseError = False)
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public Microsoft.DotNet.Interactive.Events.KernelEvent Event { get;}
    public System.Boolean IsParseError { get;}
    public System.String ToString()
  public static class CompositeKernelExtensions
    public static Microsoft.DotNet.Interactive.KernelHost UseHost(IKernelCommandAndEventSender sender, IKernelCommandAndEventReceiver receiver, System.Uri hostUri)
  public abstract class ConnectKernelCommand : System.CommandLine.Command, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.Completions.ICompletionSource
    public System.String ConnectedKernelDescription { get; set;}
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Kernel>> ConnectKernelsAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context, System.CommandLine.Invocation.InvocationContext commandLineContext)
  public class ConnectNamedPipeCommand : ConnectKernelCommand, System.Collections.Generic.IEnumerable<System.CommandLine.Symbol>, System.Collections.IEnumerable, System.CommandLine.Completions.ICompletionSource
    .ctor()
    public System.CommandLine.Option<System.String> PipeNameOption { get;}
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Kernel>> ConnectKernelsAsync(Microsoft.DotNet.Interactive.KernelInvocationContext context, System.CommandLine.Invocation.InvocationContext commandLineContext)
  public class FileSystemInfoJsonConverter : Microsoft.DotNet.Interactive.JsonConverter<System.IO.FileSystemInfo>
    .ctor()
    public System.IO.FileSystemInfo Read(ref System.Text.Json.Utf8JsonReader& reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
    public System.Void Write(System.Text.Json.Utf8JsonWriter writer, System.IO.FileSystemInfo value, System.Text.Json.JsonSerializerOptions options)
  public abstract class IKernelCommandAndEventReceiver, System.IObservable<CommandOrEvent>
  public abstract class IKernelCommandAndEventSender
    public System.Uri RemoteHostUri { get;}
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand, System.Threading.CancellationToken cancellationToken)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Threading.CancellationToken cancellationToken)
  public abstract class IKernelCommandEnvelope
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public System.String CommandType { get;}
    public System.String Token { get;}
  public abstract class IKernelEventEnvelope
    public Microsoft.DotNet.Interactive.Events.KernelEvent Event { get;}
    public System.String EventType { get;}
  public abstract class KernelClientBase
    public System.IObservable<Microsoft.DotNet.Interactive.Events.KernelEvent> KernelEvents { get;}
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.String token = null)
  public class KernelCommandAndEventReceiver, IKernelCommandAndEventReceiver, System.IDisposable, System.IObservable<CommandOrEvent>
    public static KernelCommandAndEventReceiver FromNamedPipe(System.IO.Pipes.PipeStream stream)
    public static KernelCommandAndEventReceiver FromObservable(System.IObservable<System.String> messages)
    public static KernelCommandAndEventReceiver FromTextReader(System.IO.TextReader reader)
    .ctor(ReadCommandOrEvent readCommandOrEvent)
    public System.Void Dispose()
    public System.IDisposable Subscribe(System.IObserver<CommandOrEvent> observer)
  public class KernelCommandAndEventSender, IKernelCommandAndEventSender
    public static KernelCommandAndEventSender FromNamedPipe(System.IO.Pipes.PipeStream pipeStream, System.Uri remoteHostUri)
    public static KernelCommandAndEventSender FromObserver(System.IObserver<System.String> observer, System.Uri remoteHostUri)
    public static KernelCommandAndEventSender FromTextWriter(System.IO.TextWriter writer, System.Uri remoteHostUri)
    .ctor(System.IObserver<System.String> observer, System.Uri remoteHostUri)
    .ctor(System.Func<System.String,System.Threading.CancellationToken,System.Threading.Tasks.Task> sendAsync, System.Uri remoteHostUri)
    public System.Uri RemoteHostUri { get;}
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Commands.KernelCommand kernelCommand, System.Threading.CancellationToken cancellationToken)
    public System.Threading.Tasks.Task SendAsync(Microsoft.DotNet.Interactive.Events.KernelEvent kernelEvent, System.Threading.CancellationToken cancellationToken)
  public abstract class KernelCommandEnvelope, IKernelCommandEnvelope
    public static IKernelCommandEnvelope Create(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static IKernelCommandEnvelope Deserialize(System.String json)
    public static IKernelCommandEnvelope Deserialize(System.Text.Json.JsonElement json)
    public static System.Void RegisterCommand<T>()
    public static System.Void RegisterCommand(System.Type commandType)
    public static System.Void RegisterDefaults()
    public static System.String Serialize(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static System.String Serialize(IKernelCommandEnvelope envelope)
    public System.String CommandType { get;}
    public System.String Token { get;}
  public class KernelCommandEnvelope<T> : KernelCommandEnvelope, IKernelCommandEnvelope
    .ctor(T command)
    public T Command { get;}
    public System.String CommandType { get;}
  public abstract class KernelEventEnvelope, IKernelEventEnvelope
    public static IKernelEventEnvelope Create(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public static IKernelEventEnvelope Deserialize(System.String json)
    public static IKernelEventEnvelope Deserialize(System.Text.Json.JsonElement jsonObject)
    public static IKernelEventEnvelope DeserializeWithCommand(System.String json, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static IKernelEventEnvelope DeserializeWithCommand(System.Text.Json.JsonElement jsonObject, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public static System.Void RegisterDefaults()
    public static System.Void RegisterEvent<TEvent>()
    public static System.Void RegisterEvent(System.Type eventType)
    public static System.String Serialize(Microsoft.DotNet.Interactive.Events.KernelEvent event)
    public static System.String Serialize(IKernelEventEnvelope eventEnvelope)
    public System.String CommandType { get;}
    public System.String EventType { get;}
  public class KernelEventEnvelope<T> : KernelEventEnvelope, IKernelEventEnvelope
    .ctor(T event)
    public T Event { get;}
    public System.String EventType { get;}
  public class NamedPipeKernelConnector, System.IDisposable
    .ctor(System.String pipeName)
    public System.String PipeName { get;}
    public System.Uri RemoteHostUri { get;}
    public System.Threading.Tasks.Task<ProxyKernel> CreateKernelAsync(System.String localName)
    public System.Void Dispose()
  public class ProxyKernel : Microsoft.DotNet.Interactive.Kernel, Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>, System.IDisposable
    .ctor(System.String name, IKernelCommandAndEventSender sender, IKernelCommandAndEventReceiver receiver, System.Uri remoteUri = null)
    protected Func<TCommand,Microsoft.DotNet.Interactive.KernelInvocationContext,System.Threading.Tasks.Task> CreateDefaultHandlerForCommandType<TCommand>()
     System.Threading.Tasks.Task HandleRequestKernelInfoAsync(Microsoft.DotNet.Interactive.Commands.RequestKernelInfo command, Microsoft.DotNet.Interactive.KernelInvocationContext context)
    public System.Void UpdateKernelInfo(Microsoft.DotNet.Interactive.KernelInfo kernelInfo)
  public delegate ReadCommandOrEvent : System.MulticastDelegate, System.ICloneable, System.Runtime.Serialization.ISerializable
    .ctor(System.Object object, System.IntPtr method)
    public System.IAsyncResult BeginInvoke(System.Threading.CancellationToken cancellationToken, System.AsyncCallback callback, System.Object object)
    public CommandOrEvent EndInvoke(System.IAsyncResult result)
    public CommandOrEvent Invoke(System.Threading.CancellationToken cancellationToken = null)
  public static class Serializer
    public static System.Text.Json.JsonSerializerOptions JsonSerializerOptions { get;}
    public static CommandOrEvent DeserializeCommandOrEvent(System.String json)
    public static CommandOrEvent DeserializeCommandOrEvent(System.Text.Json.JsonElement jsonObject)
Microsoft.DotNet.Interactive.Events
  public class CodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode command)
    public System.String Code { get;}
    public System.String ToString()
  public class CommandFailed : KernelCommandCompletionEvent
    .ctor(System.Exception exception, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.String message = null, System.Nullable<System.Int32> executionOrder = null)
    .ctor(System.String message, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Nullable<System.Int32> executionOrder = null)
    public System.Exception Exception { get;}
    public System.String Message { get; set;}
    public System.String ToString()
  public class CommandSucceeded : KernelCommandCompletionEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Int32 executionOrder = 0)
    public System.String ToString()
  public class CompleteCodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
    public System.String Code { get;}
    public System.String ToString()
  public class CompletionItem
    .ctor(System.String displayText, System.String kind, System.String filterText = null, System.String sortText = null, System.String insertText = null, System.Nullable<InsertTextFormat> insertTextFormat = null, System.String documentation = null)
    public System.String DisplayText { get;}
    public System.String Documentation { get; set;}
    public System.String FilterText { get;}
    public System.String InsertText { get;}
    public System.Nullable<InsertTextFormat> InsertTextFormat { get;}
    public System.String Kind { get;}
    public System.String SortText { get;}
    public System.String ToString()
  public class CompletionsProduced : KernelEvent
    .ctor(System.Collections.Generic.IEnumerable<CompletionItem> completions, Microsoft.DotNet.Interactive.Commands.RequestCompletions command, Microsoft.DotNet.Interactive.LinePositionSpan linePositionSpan = null)
    public System.Collections.Generic.IEnumerable<CompletionItem> Completions { get;}
    public Microsoft.DotNet.Interactive.LinePositionSpan LinePositionSpan { get;}
  public class DiagnosticsProduced : KernelEvent
    .ctor(System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> diagnostics, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedDiagnostics = null)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.Diagnostic> Diagnostics { get;}
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> FormattedDiagnostics { get;}
    public System.String ToString()
  public class DisplayedValueProduced : DisplayEvent
    .ctor(System.Object value, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class DisplayedValueUpdated : DisplayEvent
    .ctor(System.Object value, System.String valueId, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null)
  public abstract class DisplayEvent : KernelEvent
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> FormattedValues { get;}
    public System.Object Value { get;}
    public System.String ValueId { get;}
    public System.String ToString()
  public class ErrorProduced : DisplayEvent
    .ctor(System.String message, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null)
    public System.String Message { get;}
  public class HoverTextProduced : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.RequestHoverText command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> content, Microsoft.DotNet.Interactive.LinePositionSpan linePositionSpan = null)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> Content { get;}
    public Microsoft.DotNet.Interactive.LinePositionSpan LinePositionSpan { get;}
  public class IncompleteCodeSubmissionReceived : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
  public class InputProduced : KernelEvent
    .ctor(System.String value, Microsoft.DotNet.Interactive.Commands.RequestInput command)
    public System.String Value { get;}
  public enum InsertTextFormat : System.Enum, System.IComparable, System.IConvertible, System.IFormattable, System.ISpanFormattable
    PlainText=1
    Snippet=2
  public abstract class KernelCommandCompletionEvent : KernelEvent
    public System.Nullable<System.Int32> ExecutionOrder { get;}
  public abstract class KernelEvent
    public Microsoft.DotNet.Interactive.Commands.KernelCommand Command { get;}
    public Microsoft.DotNet.Interactive.EventRoutingSlip RoutingSlip { get;}
    public System.String ToString()
  public class KernelExtensionLoaded : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    .ctor(Microsoft.DotNet.Interactive.IKernelExtension kernelExtension, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.IKernelExtension KernelExtension { get;}
  public class KernelInfoProduced : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.KernelInfo kernelInfo, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.KernelInfo KernelInfo { get;}
  public class KernelReady : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.KernelInfo[] kernelInfos)
    public Microsoft.DotNet.Interactive.KernelInfo[] KernelInfos { get;}
  public class PackageAdded : KernelEvent
    .ctor(Microsoft.DotNet.Interactive.ResolvedPackageReference packageReference, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public Microsoft.DotNet.Interactive.ResolvedPackageReference PackageReference { get;}
    public System.String ToString()
  public class ReturnValueProduced : DisplayEvent
    .ctor(System.Object value, Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class SignatureHelpProduced : KernelEvent
    public static SignatureHelpProduced Empty(Microsoft.DotNet.Interactive.Commands.RequestSignatureHelp command)
    .ctor(Microsoft.DotNet.Interactive.Commands.RequestSignatureHelp command, System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.SignatureInformation> signatures, System.Int32 activeSignatureIndex, System.Int32 activeParameterIndex)
    public System.Int32 ActiveParameterIndex { get;}
    public System.Int32 ActiveSignatureIndex { get;}
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.SignatureInformation> Signatures { get;}
  public class StandardErrorValueProduced : DisplayEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class StandardOutputValueProduced : DisplayEvent
    .ctor(Microsoft.DotNet.Interactive.Commands.KernelCommand command, System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.FormattedValue> formattedValues = null, System.String valueId = null)
  public class ValueInfosProduced : KernelEvent
    .ctor(System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo> valueInfos, Microsoft.DotNet.Interactive.Commands.RequestValueInfos command)
    public System.Collections.Generic.IReadOnlyCollection<Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo> ValueInfos { get;}
  public class ValueProduced : KernelEvent
    .ctor(System.Object value, System.String name, Microsoft.DotNet.Interactive.FormattedValue formattedValue, Microsoft.DotNet.Interactive.Commands.RequestValue command)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String Name { get;}
    public System.Object Value { get;}
  public class WorkingDirectoryChanged : KernelEvent
    .ctor(System.String workingDirectory, Microsoft.DotNet.Interactive.Commands.KernelCommand command)
    public System.String WorkingDirectory { get;}
Microsoft.DotNet.Interactive.Http
  public static class JavascriptUtilities
    public static System.String GetCodeForEnsureRequireJs(System.Uri requireJsUri = null, System.String onRequirejsLoadedCallBackName = null)
Microsoft.DotNet.Interactive.Parsing
  public class ActionDirectiveNode : DirectiveNode
    public System.String ParentKernelName { get;}
  public enum DiagnosticSeverity : System.Enum, System.IComparable, System.IConvertible, System.IFormattable, System.ISpanFormattable
    Hidden=0
    Info=1
    Warning=2
    Error=3
  public class DirectiveArgsToken : SyntaxToken
  public class DirectiveHelpBuilder : System.CommandLine.Help.HelpBuilder
    .ctor(System.String rootCommandName)
    public System.String GetHelpForSymbol(System.CommandLine.Symbol symbol)
    public System.Void Write(System.CommandLine.Help.HelpContext context)
  public abstract class DirectiveNode : LanguageNode
    public System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> GetDiagnostics()
    public System.CommandLine.Parsing.ParseResult GetDirectiveParseResult()
  public class DirectiveToken : SyntaxToken
    public System.String DirectiveName { get;}
  public class KernelNameDirectiveNode : DirectiveNode
  public class LanguageNode : SyntaxNode
    public System.String Name { get;}
    public System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> GetDiagnostics()
  public class LanguageSpecificParseResult
    public static LanguageSpecificParseResult None { get;}
    .ctor()
    public System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> GetDiagnostics()
  public class LanguageToken : SyntaxToken
  public class PolyglotSubmissionNode : SyntaxNode
    public System.String DefaultLanguage { get;}
  public class PolyglotSyntaxTree
    public System.Int32 Length { get;}
    public System.Int32 GetAbsolutePosition(Microsoft.DotNet.Interactive.LinePosition linePosition)
    public System.String GetLanguageAtPosition(System.Int32 position)
    public SyntaxNode GetRoot()
    public System.String ToString()
  public class SubmissionParser
    public static Microsoft.DotNet.Interactive.Events.CompletionItem CompletionItemFor(System.String name, System.CommandLine.Parsing.ParseResult parseResult)
    .ctor(Microsoft.DotNet.Interactive.Kernel kernel)
    public System.Collections.Generic.IReadOnlyList<System.CommandLine.Command> Directives { get;}
    public System.Void AddDirective(System.CommandLine.Command command)
    public PolyglotSyntaxTree Parse(System.String code, System.String language = null)
    public System.Void SetInputTypeHint(System.Type expectedType, System.String inputTypeHint)
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Commands.KernelCommand> SplitSubmission(Microsoft.DotNet.Interactive.Commands.SubmitCode submitCode)
    public System.Collections.Generic.IReadOnlyList<Microsoft.DotNet.Interactive.Commands.KernelCommand> SplitSubmission(Microsoft.DotNet.Interactive.Commands.RequestDiagnostics requestDiagnostics)
  public abstract class SyntaxNode : SyntaxNodeOrToken
    public System.Collections.Generic.IEnumerable<SyntaxNode> ChildNodes { get;}
    public System.Collections.Generic.IReadOnlyList<SyntaxNodeOrToken> ChildNodesAndTokens { get;}
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> ChildTokens { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public System.Boolean Contains(SyntaxNode node)
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens()
    public System.Collections.Generic.IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf()
    public SyntaxNode FindNode(Microsoft.CodeAnalysis.Text.TextSpan span)
    public SyntaxNode FindNode(System.Int32 position)
    public SyntaxToken FindToken(System.Int32 position)
    public System.Collections.Generic.IEnumerable<Microsoft.DotNet.Interactive.Diagnostic> GetDiagnostics()
  public abstract class SyntaxNodeOrToken
    public SyntaxNode Parent { get;}
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public PolyglotSyntaxTree SyntaxTree { get;}
    public System.String Text { get;}
    protected Microsoft.CodeAnalysis.Text.SourceText get_SourceText()
    public System.String ToString()
  public abstract class SyntaxToken : SyntaxNodeOrToken
    public Microsoft.CodeAnalysis.Text.TextSpan Span { get;}
    public System.String ToString()
  public class TriviaToken : SyntaxToken
Microsoft.DotNet.Interactive.Utility
  public class AddPackageResult : CommandLineResult
    .ctor(System.Int32 exitCode, System.Collections.Generic.IReadOnlyCollection<System.String> output = null, System.Collections.Generic.IReadOnlyCollection<System.String> error = null)
    public System.Collections.Generic.IEnumerable<System.String> DetailedErrors { get;}
    public System.String InstalledVersion { get;}
  public static class AsyncContext
    public static System.Nullable<System.Int32> Id { get;}
    public static System.Boolean TryEstablish(ref System.Int32& id)
  public static class CommandLine
    public static System.String AppendArgs(System.String append = null)
    public static System.Threading.Tasks.Task<System.Int32> Complete()
    public static System.Threading.Tasks.Task<CommandLineResult> Execute(System.IO.FileInfo exePath, System.String args, System.IO.DirectoryInfo workingDir = null, System.Nullable<System.TimeSpan> timeout = null)
    public static System.Threading.Tasks.Task<CommandLineResult> Execute(System.String command, System.String args, System.IO.DirectoryInfo workingDir = null, System.Nullable<System.TimeSpan> timeout = null)
    public static System.Diagnostics.Process StartProcess(System.String command, System.String args, System.IO.DirectoryInfo workingDir, System.Action<System.String> output = null, System.Action<System.String> error = null, System.ValueTuple<System.String,System.String> environmentVariables)
    public static Task<T> Timeout<T>(System.TimeSpan timeout)
  public class CommandLineInvocationException : System.Exception, System.Runtime.Serialization.ISerializable
    .ctor(CommandLineResult result, System.String message = null)
  public class CommandLineResult
    .ctor(System.Int32 exitCode, System.Collections.Generic.IReadOnlyCollection<System.String> output = null, System.Collections.Generic.IReadOnlyCollection<System.String> error = null)
    public System.Collections.Generic.IReadOnlyCollection<System.String> Error { get;}
    public System.Int32 ExitCode { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.String> Output { get;}
    public System.Void ThrowOnFailure(System.String message = null)
  public static class ConsoleOutput
    public static System.IDisposable InitializeFromAsyncContext(System.Int32 asyncContextId)
    public static System.IDisposable Subscribe(System.Func<ObservableConsole,System.IDisposable> subscribe)
   class ObservableConsole, System.IEquatable<ObservableConsole>
    public static System.Boolean op_Equality(ObservableConsole left, ObservableConsole right)
    public static System.Boolean op_Inequality(ObservableConsole left, ObservableConsole right)
    .ctor(System.IObservable<System.String> Out, System.IObservable<System.String> Error)
    public System.IObservable<System.String> Error { get; set;}
    public System.IObservable<System.String> Out { get; set;}
    public ObservableConsole <Clone>$()
    public System.Void Deconstruct(ref System.IObservable<System.String> Out, ref System.IObservable<System.String> Error)
    public System.Boolean Equals(System.Object obj)
    public System.Boolean Equals(ObservableConsole other)
    protected System.Type get_EqualityContract()
    public System.Int32 GetHashCode()
    protected System.Boolean PrintMembers(System.Text.StringBuilder builder)
    public System.String ToString()
  public static class DirectoryUtility
    public static System.IO.DirectoryInfo EnsureExists()
  public class DisposableDirectory, System.IDisposable
    public static DisposableDirectory Create()
    .ctor(System.IO.DirectoryInfo directory)
    public System.IO.DirectoryInfo Directory { get;}
    public System.Void Dispose()
  public class Dotnet
    public static System.IO.FileInfo Path { get;}
    public static System.String GetDataFromAppDomain(System.String propertyName)
    .ctor(System.IO.DirectoryInfo workingDirectory = null)
    public System.Threading.Tasks.Task<AddPackageResult> AddPackage(System.String packageId, System.String version = null)
    public System.Threading.Tasks.Task<CommandLineResult> AddReference(System.IO.FileInfo projectToReference, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Build(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Clean(System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Execute(System.String args, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> New(System.String templateName, System.String args = null)
    public System.Threading.Tasks.Task<CommandLineResult> Pack(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Threading.Tasks.Task<CommandLineResult> Publish(System.String args = null, System.Nullable<System.TimeSpan> timeout = null)
    public System.Diagnostics.Process StartProcess(System.String args, System.Action<System.String> output = null, System.Action<System.String> error = null)
    public System.Threading.Tasks.Task<CommandLineResult> ToolInstall(System.String packageName, System.IO.DirectoryInfo toolPath = null, System.String addSource = null, System.String version = null)
    public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<System.String>> ToolList(System.IO.DirectoryInfo directory = null)
    public System.Threading.Tasks.Task<CommandLineResult> VSTest(System.String args)
  public static class FileNameUtilities
    public static System.String ChangeExtension(System.String path, System.String extension)
    public static System.String ExecutableName()
    public static System.String GetExtension(System.String path)
    public static System.String GetFileName(System.String path, System.Boolean includeExtension = True)
  public class GCPressure, System.IDisposable
    .ctor(System.Int64 bytesAllocated)
    public System.Void Dispose()
  public class MultiplexingTextWriter : System.IO.TextWriter, System.IAsyncDisposable, System.IDisposable
    .ctor(System.String name, System.Func<System.IO.TextWriter> createTextWriter = null, System.IO.TextWriter defaultWriter = null)
    public System.Text.Encoding Encoding { get;}
    public System.Collections.Generic.IEnumerable<System.IO.TextWriter> Writers { get;}
    protected System.Void Dispose(System.Boolean disposing)
    public System.IDisposable EnsureInitializedForCurrentAsyncContext()
    public System.IObservable<System.String> GetObservable()
    public System.String ToString()
    public System.Void Write(System.Char value)
    public System.Void Write(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void Write(System.String value)
    public System.Void Write(System.Boolean value)
    public System.Void Write(System.Char[] buffer)
    public System.Void Write(System.Decimal value)
    public System.Void Write(System.Double value)
    public System.Void Write(System.Int32 value)
    public System.Void Write(System.Int64 value)
    public System.Void Write(System.Object value)
    public System.Void Write(System.ReadOnlySpan<System.Char> buffer)
    public System.Void Write(System.Single value)
    public System.Void Write(System.String format, System.Object arg0)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void Write(System.String format, System.Object[] arg)
    public System.Void Write(System.UInt32 value)
    public System.Void Write(System.UInt64 value)
    public System.Threading.Tasks.Task WriteAsync(System.Char value)
    public System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = null)
    public System.Threading.Tasks.Task WriteAsync(System.String value)
    public System.Void WriteLine()
    public System.Void WriteLine(System.Char value)
    public System.Void WriteLine(System.Boolean value)
    public System.Void WriteLine(System.Char[] buffer)
    public System.Void WriteLine(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void WriteLine(System.Decimal value)
    public System.Void WriteLine(System.Double value)
    public System.Void WriteLine(System.Int32 value)
    public System.Void WriteLine(System.Int64 value)
    public System.Void WriteLine(System.Object value)
    public System.Void WriteLine(System.ReadOnlySpan<System.Char> buffer)
    public System.Void WriteLine(System.Single value)
    public System.Void WriteLine(System.String value)
    public System.Void WriteLine(System.String format, System.Object arg0)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void WriteLine(System.String format, System.Object[] arg)
    public System.Void WriteLine(System.UInt32 value)
    public System.Void WriteLine(System.UInt64 value)
    public System.Threading.Tasks.Task WriteLineAsync()
    public System.Threading.Tasks.Task WriteLineAsync(System.Char value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<System.Char> buffer, System.Threading.CancellationToken cancellationToken = null)
    public System.Threading.Tasks.Task WriteLineAsync(System.String value)
  public class ObservableStringWriter : System.IO.StringWriter, System.IAsyncDisposable, System.IDisposable, System.IObservable<System.String>
    .ctor()
    protected System.Void Dispose(System.Boolean disposing)
    public System.IDisposable Subscribe(System.IObserver<System.String> observer)
    public System.Void Write(System.Char value)
    public System.Void Write(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void Write(System.String value)
    public System.Void Write(System.Boolean value)
    public System.Void Write(System.Char[] buffer)
    public System.Void Write(System.Decimal value)
    public System.Void Write(System.Double value)
    public System.Void Write(System.Int32 value)
    public System.Void Write(System.Int64 value)
    public System.Void Write(System.Object value)
    public System.Void Write(System.Single value)
    public System.Void Write(System.String format, System.Object arg0)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1)
    public System.Void Write(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void Write(System.String format, System.Object[] arg)
    public System.Void Write(System.UInt32 value)
    public System.Void Write(System.UInt64 value)
    public System.Threading.Tasks.Task WriteAsync(System.Char value)
    public System.Threading.Tasks.Task WriteAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteAsync(System.String value)
    public System.Void WriteLine()
    public System.Void WriteLine(System.Boolean value)
    public System.Void WriteLine(System.Char value)
    public System.Void WriteLine(System.Char[] buffer)
    public System.Void WriteLine(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Void WriteLine(System.Decimal value)
    public System.Void WriteLine(System.Double value)
    public System.Void WriteLine(System.Int32 value)
    public System.Void WriteLine(System.Int64 value)
    public System.Void WriteLine(System.Object value)
    public System.Void WriteLine(System.Single value)
    public System.Void WriteLine(System.String value)
    public System.Void WriteLine(System.String format, System.Object arg0)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1)
    public System.Void WriteLine(System.String format, System.Object arg0, System.Object arg1, System.Object arg2)
    public System.Void WriteLine(System.String format, System.Object[] arg)
    public System.Void WriteLine(System.UInt32 value)
    public System.Void WriteLine(System.UInt64 value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char value)
    public System.Threading.Tasks.Task WriteLineAsync(System.Char[] buffer, System.Int32 index, System.Int32 count)
    public System.Threading.Tasks.Task WriteLineAsync(System.String value)
    public System.Threading.Tasks.Task WriteLineAsync()
    public System.Collections.Generic.IEnumerable<System.String> Writes()
  public static class Paths
    public static System.String DotnetHomePath { get;}
    public static System.String DotnetToolsPath { get;}
    public static System.String DotnetUserProfileFolderPath { get;}
    public static System.String NugetCache { get;}
    public static System.String UserProfile { get;}
  public static class SourceUtilities
    public static System.Int32 ComputeReplacementStartPosition(System.String code, System.Int32 cursorPosition)
    public static System.Int32 GetCursorOffsetFromPosition(System.String code, Microsoft.DotNet.Interactive.LinePosition position)
    public static Microsoft.DotNet.Interactive.LinePositionSpan GetLinePositionSpanFromStartAndEndIndices(System.String code, System.Int32 startIndex, System.Int32 endIndex)
    public static Microsoft.DotNet.Interactive.LinePosition GetPositionFromCursorOffset(System.String code, System.Int32 cursorOffset)
Microsoft.DotNet.Interactive.ValueSharing
  public class KernelValue
    .ctor(KernelValueInfo valueInfo, System.Object value, System.String kernelName)
    public System.String KernelName { get;}
    public System.String Name { get;}
    public System.Type Type { get;}
    public System.Object Value { get;}
  public class KernelValueInfo
    .ctor(System.String name, Microsoft.DotNet.Interactive.FormattedValue formattedValue, System.Type type = null, System.String typeName = null)
    public Microsoft.DotNet.Interactive.FormattedValue FormattedValue { get;}
    public System.String Name { get;}
    public System.Collections.Generic.IReadOnlyCollection<System.String> PreferredMimeTypes { get; set;}
    public System.Type Type { get;}
    public System.String TypeName { get; set;}
System
  public static class DisplayExtensions
    public static Microsoft.DotNet.Interactive.DisplayedValue Display(String[] mimeTypes)
    public static Microsoft.DotNet.Interactive.DisplayedValue DisplayAs(String mimeType)
    public static Microsoft.DotNet.Interactive.DisplayedValue DisplayTable<T>(String[] mimeTypes)
